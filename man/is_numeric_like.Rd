% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/is-numeric-like.R
\name{is_numeric_like}
\alias{is_numeric_like}
\title{Test whether a vector is numeric or coercible to numeric}
\usage{
is_numeric_like(x)
}
\arguments{
\item{x}{Object to be tested.}
}
\value{
Boolean (length 1).
}
\description{
\code{is_numeric_like()} tests whether an object is "coercible to
numeric" by the standards of scrutiny. This means:
\itemize{
\item Integer and double vectors are \code{TRUE}.
\item Booleans are always \code{FALSE}, as are non-vector objects.
\item Other vectors (most likely strings) are \code{TRUE} if all their non-\code{NA}
values can be coerced to non-\code{NA} numeric values, and \code{FALSE} otherwise.
\item Factors are first coerced to string, then tested.
\item If all values are \code{NA}, the output is also \code{NA}.
}

See details for discussion.
}
\details{
The scrutiny package often deals with "number-strings", i.e.,
strings that can be seamlessly coerced to numeric. This is a matter of
representing numbers in a certain format, so what counts here is the way
values are displayed, not how they are stored.

\code{is_numeric_like()} returns \code{FALSE} for Booleans because they are displayed
as words, not as numbers, and the usual coercion rules would be misleading
in this context. Likewise, the function treats factors like strings because
that is much closer to the way they are displayed -- the fact that factors
are stored as integers is irrelevant.
}
\examples{
# Numeric vectors are `TRUE`:
is_numeric_like(1:5)
is_numeric_like(2.47)

# Strings are `TRUE` if they can be coerced
# to non-`NA` numbers, and `FALSE` otherwise:
is_numeric_like("42")
is_numeric_like("xyz")

# Factors are treated like their
# string equivalents:
is_numeric_like(as.factor("42"))
is_numeric_like(as.factor("xyz"))

# Booleans are always false:
is_numeric_like(c(TRUE, FALSE))

# If all values are `NA`, so is the output:
is_numeric_like(c(NA, NA, NA))
}
\seealso{
The \href{https://vctrs.r-lib.org/}{vctrs} package provides a
serious typing framework for R; much in contrast to this rather ad-hoc and
use case-specific function.
}
