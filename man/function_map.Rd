% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/function-map.R
\name{function_map}
\alias{function_map}
\title{Create new \verb{*_map()} functions}
\usage{
function_map(.fun, .reported, .name_test, .name_class = NULL, ...)
}
\arguments{
\item{.fun}{Single-case consistency testing function that will be applied to
each row in a data frame, such as the (non-exported) scrutiny functions
\code{grim_scalar()} and \code{debit_scalar()}. It needs to return a Boolean value of
length 1, i.e., \code{TRUE} or \code{FALSE}.}

\item{.reported}{String. Names of the columns to be tested.}

\item{.name_test}{String (length 1). Plain-text name of the consistency test,
such as \code{"GRIM"}.}

\item{.name_class}{String. One or more classes to be added to the output data
frame. Default is \code{NULL}, i.e., no extra class (but see \emph{Details}).}

\item{...}{Arguments passed down to \code{.fun}.}
}
\value{
A "manufactured" function with these arguments:
\itemize{
\item \code{data}: Data frame with all the columns named in \code{.reported}. It needs to
have columns named after the key arguments in \code{.fun}. Other columns are
permitted.
\item \code{reported}, \code{fun}, \code{name_class}: Same as when calling \code{function_map()} but
spelled without dots. You can override these defaults when calling the
manufactured function.
\item \code{...}: Arguments passed down to \code{fun}.
}

The manufactured function should then return a tibble that includes
\code{"consistency"}: a Boolean column that shows whether the values to its left
are mutually consistent (\code{TRUE}) or not (\code{FALSE}).
}
\description{
\code{function_map()} creates new basic mapper functions for
consistency tests, such as \code{grim_map()} or \code{debit_map()}.
}
\details{
The output tibble returned by the manufactured function will inherit
one or two classes independently of the \code{.name_class} argument:
\itemize{
\item It will inherit a class named \code{"scr_{tolower(.name_test)}_map"}; for
example, \code{"scr_grim_map"} if \code{.name_test} is \code{"GRIM"}.
\item If a \code{rounding} argument is specified via \code{...}, or else if \code{.fun} has a
\code{rounding} argument with a default, the output tibble inherits a class
named \code{"scr_rounding_{rounding}"}; for example,
\code{"scr_rounding_up_or_down"}.
}
}
\examples{
# Basic test implementation for "SCHLIM",
# a mock test with no real significance:
schlim_scalar <- function(y, n) {
  (y / 3) > n
}

# Let the function factory produce
# a mapper function for SCHLIM:
schlim_map <- function_map(
  .fun = schlim_scalar,
  .reported = c("y", "n"),
  .name_test = "SCHLIM"
)

# Example data:
df1 <- tibble::tibble(y = 16:25, n = 3:12)

# Call the "manufactured" function:
schlim_map(df1)


# Advice on exporting manufactured functions ----------------

# (The guidelines below were adapted from purrr:
# https://purrr.tidyverse.org/reference/faq-adverbs-export.html)

# If you want to export a function produced
# by `function_map()` from your own package,
# follow this pattern, except for the `if`-wrapping:

if (FALSE) {

  schlim_map <- function(...) "dummy"

  .onLoad <- function(lib, pkg) {
    schlim_map <<- function_map(
      .fun = schlim_scalar,
      .reported = c("y", "n"),
      .name_test = "SCHLIM"
    )
  }

}

# The same applies to functions
# produced with scrutiny's other
# function factories, `function_map_seq()`
# and `function_map_total_n()`.
}
