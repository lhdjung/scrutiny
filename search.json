[{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement jung-lukas@gmx.net. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://lhdjung.github.io/scrutiny/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://lhdjung.github.io/scrutiny/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":"https://lhdjung.github.io/scrutiny/articles/debit.html","id":"debit-basics","dir":"Articles","previous_headings":"","what":"DEBIT basics","title":"DEBIT","text":"Consider summary data binary distribution: mean 0.35, SD 0.18, sample size 20. test consistency, run : grim(), mean needs string. (true SD.) strings preserve trailing zeros, can crucial DEBIT. Numeric values don’t, even converting strings won’t help. workaround larger numbers values, restore_zeros(), discussed Data wrangling vignette. debit() arguments, can used within debit_map(). Since debit_map() useful function practice, arguments discussed context.","code":"debit(x = \"0.35\", sd = \"0.18\", n = 20) #> [1] FALSE"},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/debit.html","id":"working-with-debit_map","dir":"Articles","previous_headings":"Testing multiple cases","what":"Working with debit_map()","title":"DEBIT","text":"want test handful cases, recommended way enter data frame run debit_map() data frame. example data Heathers Brown’s (2019) Table 1. useful way enter data copy PDF file paste tibble::tribble(), available via scrutiny: Now, simply run debit_map() data frame: x, sd, n columns input. main result, consistency, DEBIT consistency former three columns. function checks summary data really can describe binary distribution: DEBIT makes sense binary means SDs. debit() debit_map() check inputs data, fail : Compared grim_map(), debit_map() straightforward. percentage conversion accounting multiple scale items. true comparing basic grim() debit() functions. However, implementations tap scrutiny’s arsenal rounding procedures, discussed next.","code":"flying_pigs <- tibble::tribble(   ~x,         ~sd,   \"0.53\",     \"0.50\",   \"0.44\",     \"0.50\",   \"0.77\",     \"0.42\",   \"0.19\",     \"0.35\",   \"0.34\",     \"0.47\",   \"0.93\",     \"0.25\",   \"0.12\",     \"0.33\", ) %>%    mutate(n = 1683)   flying_pigs #> # A tibble: 7 × 3 #>   x     sd        n #>   <chr> <chr> <dbl> #> 1 0.53  0.50   1683 #> 2 0.44  0.50   1683 #> 3 0.77  0.42   1683 #> 4 0.19  0.35   1683 #> 5 0.34  0.47   1683 #> 6 0.93  0.25   1683 #> 7 0.12  0.33   1683 flying_pigs %>%    debit_map() #> # A tibble: 7 × 11 #>   x     sd        n consistency rounding   sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>         <dbl> <lgl>            <dbl> #> 1 0.53  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 2 0.44  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 3 0.77  0.42   1683 TRUE        up_or_down    0.415 TRUE             0.425 #> 4 0.19  0.35   1683 FALSE       up_or_down    0.345 TRUE             0.355 #> 5 0.34  0.47   1683 TRUE        up_or_down    0.465 TRUE             0.475 #> 6 0.93  0.25   1683 TRUE        up_or_down    0.245 TRUE             0.255 #> 7 0.12  0.33   1683 TRUE        up_or_down    0.325 TRUE             0.335 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl> pigs3  # data saved within the package #> # A tibble: 7 × 3 #>   x     sd        n #>   <chr> <chr> <dbl> #> 1 0.53  0.50   1683 #> 2 0.44  0.50   1683 #> 3 0.77  0.42   1683 #> 4 0.19  0.35   1683 #> 5 0.34  0.47   1683 #> 6 0.93  0.25   1683 #> 7 0.12  0.33   1683  pigs3 %>%    debit_map() #> # A tibble: 7 × 11 #>   x     sd        n consistency rounding   sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>         <dbl> <lgl>            <dbl> #> 1 0.53  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 2 0.44  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 3 0.77  0.42   1683 TRUE        up_or_down    0.415 TRUE             0.425 #> 4 0.19  0.35   1683 FALSE       up_or_down    0.345 TRUE             0.355 #> 5 0.34  0.47   1683 TRUE        up_or_down    0.465 TRUE             0.475 #> 6 0.93  0.25   1683 TRUE        up_or_down    0.245 TRUE             0.255 #> 7 0.12  0.33   1683 TRUE        up_or_down    0.325 TRUE             0.335 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl> pigs1  # no binary summary data! #> # A tibble: 12 × 2 #>    x         n #>    <chr> <dbl> #>  1 7.22     32 #>  2 4.74     25 #>  3 5.23     29 #>  4 2.57     24 #>  5 6.77     27 #>  6 2.68     28 #>  7 7.01     29 #>  8 7.38     26 #>  9 3.14     27 #> 10 6.89     31 #> 11 5.00     25 #> 12 0.24     28  pigs1 %>%    debit_map() #> Error: DEBIT only works with binary summary data #> ! Binary mean (`x`) values must range from 0 to 1. #> ✖ 11 out of 12 `x` values are not in that range, starting with 7.22, 4.74, and #>   5.23."},{"path":"https://lhdjung.github.io/scrutiny/articles/debit.html","id":"rounding","dir":"Articles","previous_headings":"Testing multiple cases","what":"Rounding","title":"DEBIT","text":"scrutiny package provides infrastructure reconstructing rounded numbers. can commanded within debit() debit_map(). Several arguments allow stating precise way original numbers supposedly rounded. First foremost rounding argument. takes string rounding procedure’s name, leads number rounded either ways: Rounded \"\" \"\" 5. Note SAS, SPSS, Stata, Matlab, Excel round \"\" 5, whereas Python rounds \"\" 5. Rounded \"even\" using base R’s round(). Rounded \"up_from\" \"down_from\" number, needs specified via threshold argument. Given \"ceiling\" \"floor\" respective decimal place. Rounded towards zero \"trunc\" away zero \"anti_trunc\". default, \"up_or_down\", allows numbers rounded either \"\" \"\" 5 using DEBIT; likewise \"up_from_or_down_from\" \"ceiling_or_floor\". procedures, see documentation round(), round_up(), round_ceiling(). include ways rounding. Points 3 5 list quite obscure options included cover wide spectrum possible rounding procedures. true threshold symmetric arguments, aren’t discussed . default, debit() debit_map() accept values rounded either 5. reason impose stricter assumptions way x rounded, specify rounding accordingly: Although changing rounding procedure didn’t make difference DEBIT consistency , important account different ways numbers might rounded, demonstrate given results robust variable decisions. err side caution, default rounding permissive \"up_or_down\".","code":"flying_pigs %>%    debit_map(rounding = \"up\") #> # A tibble: 7 × 11 #>   x     sd        n consistency rounding sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>       <dbl> <lgl>            <dbl> #> 1 0.53  0.50   1683 TRUE        up          0.495 TRUE             0.505 #> 2 0.44  0.50   1683 TRUE        up          0.495 TRUE             0.505 #> 3 0.77  0.42   1683 TRUE        up          0.415 TRUE             0.425 #> 4 0.19  0.35   1683 FALSE       up          0.345 TRUE             0.355 #> 5 0.34  0.47   1683 TRUE        up          0.465 TRUE             0.475 #> 6 0.93  0.25   1683 TRUE        up          0.245 TRUE             0.255 #> 7 0.12  0.33   1683 TRUE        up          0.325 TRUE             0.335 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl>  flying_pigs %>%    debit_map(rounding = \"even\") #> # A tibble: 7 × 11 #>   x     sd        n consistency rounding sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>       <dbl> <lgl>            <dbl> #> 1 0.53  0.50   1683 TRUE        even        0.495 FALSE            0.505 #> 2 0.44  0.50   1683 TRUE        even        0.495 FALSE            0.505 #> 3 0.77  0.42   1683 TRUE        even        0.415 FALSE            0.425 #> 4 0.19  0.35   1683 FALSE       even        0.345 FALSE            0.355 #> 5 0.34  0.47   1683 TRUE        even        0.465 FALSE            0.475 #> 6 0.93  0.25   1683 TRUE        even        0.245 FALSE            0.255 #> 7 0.12  0.33   1683 TRUE        even        0.325 FALSE            0.335 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl>"},{"path":"https://lhdjung.github.io/scrutiny/articles/debit.html","id":"summarize-results-with-audit","dir":"Articles","previous_headings":"","what":"Summarize results with audit()","title":"DEBIT","text":"Following call debit_map(), generic function audit() summarizes test results: columns — incons_cases: number inconsistent value sets. all_cases: total number value sets. incons_rate: proportion DEBIT-inconsistent value sets. mean_x: average binary distribution means. mean_sd: average binary distribution standard deviations. distinct_n: number different sample sizes.","code":"flying_pigs %>%    debit_map() %>%    audit() #> # A tibble: 1 × 6 #>   incons_cases all_cases incons_rate mean_x mean_sd distinct_n #>          <dbl>     <int>       <dbl>  <dbl>   <dbl>      <dbl> #> 1            1         7       0.143  0.474   0.403          1"},{"path":"https://lhdjung.github.io/scrutiny/articles/debit.html","id":"visualize-results-with-debit_plot","dir":"Articles","previous_headings":"","what":"Visualize results with debit_plot()","title":"DEBIT","text":"specialized visualization function DEBIT results, debit_plot(). run debit_map()’s output. fail otherwise.  DEBIT-consistent value pairs blue, inconsistent ones red. black arc DEBIT line: Given sample size, pairs mean SD values DEBIT-consistent cross line. precisely, inner boxes must cross line — outer boxes just pointers inner ones, case poorly visible. inherent meaning. Except colors, inner boxes must look exactly like : sizes shapes completely determined mean SD values. Since inner boxes enlarged , outer boxes might helpful spot first glance. However, outer boxes desired, can turned like :  Color settings ggplot2-typical options available via arguments, settings handed ggrepel::geom_text_repel(), creates labels. , see debit_plot()’s documentation.","code":"# Determine plot theme for the remaining session: ggplot2::theme_minimal(base_size = 12) %>%    ggplot2::theme_set()  flying_pigs %>%    debit_map() %>%    debit_plot() flying_pigs %>%    debit_map() %>%    debit_plot(show_outer_boxes = FALSE)"},{"path":"https://lhdjung.github.io/scrutiny/articles/debit.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"DEBIT","text":"Heathers, James . J., und Nicholas J. L. Brown. 2019. „DEBIT: Simple Consistency Test Binary Data\". https://osf.io/5vb3u/.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"few-cases-grim","dir":"Articles","previous_headings":"GRIM testing","what":"Few cases: grim()","title":"GRIM","text":"test reported mean 5.27 granular scale GRIM-consistent sample size 43, run : Note x, reported mean, needs string. reason strings preserve trailing zeros, can crucial GRIM-testing. Numeric values don’t, even converting strings won’t help. workaround larger numbers values, restore_zeros(), discussed vignette(\"wrangling\"). grim() parameters, can used within grim_map(). parameters discussed context grim_map() often useful function practice. Furthermore, although grim() vectorized, grim_map() safe convenient testing multiple combinations means/proportions sample sizes.","code":"grim(x = \"5.27\", n = 43) #>  5.27  #> FALSE"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"many-cases-grim_map","dir":"Articles","previous_headings":"GRIM testing","what":"Many cases: grim_map()","title":"GRIM","text":"want GRIM-test handful cases, recommended way enter data frame run grim_map() data frame. Two different ways discussed vignette(\"wrangling\"), , describe easily accessible solution single table. Copy summary data PDF file paste tibble::tribble(), available via scrutiny: Use RStudio’s multiple cursors draw quotation marks around x values, set commas end. See vignette(\"wrangling\"), section copy paste, sure . Now, simply run grim_map() data frame: x n columns input. default, number items composing mean assumed 1. main result, consistency, GRIM consistency former three columns. ratio column, see section GRIM ratio.","code":"flying_pigs1 <- tribble(   ~x, \"8.97\", \"2.61\", \"7.26\", \"3.64\", \"9.26\", \"10.46\", \"7.39\" ) %>%    mutate(n = 28) grim_map(flying_pigs1) #> # A tibble: 7 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 8.97     28     1 FALSE        0.72 #> 2 2.61     28     1 TRUE         0.72 #> 3 7.26     28     1 FALSE        0.72 #> 4 3.64     28     1 TRUE         0.72 #> 5 9.26     28     1 FALSE        0.72 #> 6 10.46    28     1 TRUE         0.72 #> 7 7.39     28     1 TRUE         0.72"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"scale-items","dir":"Articles","previous_headings":"GRIM testing","what":"Scale items","title":"GRIM","text":"mean composed multiple items, set items parameter number. hypothetical means three-items scale. single-item default, half wrongly flagged inconsistent: Yet, consistent correct number items stated: also possible include items column data frame instead:","code":"jpap_1 <- tribble(    ~x,   \"5.90\",   \"5.71\",   \"3.50\",   \"3.82\",   \"4.61\",   \"5.24\", ) %>%    mutate(n = 40)  jpap_1 %>%    grim_map()  # default is wrong here! #> # A tibble: 6 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 5.90     40     1 TRUE          0.6 #> 2 5.71     40     1 FALSE         0.6 #> 3 3.50     40     1 TRUE          0.6 #> 4 3.82     40     1 TRUE          0.6 #> 5 4.61     40     1 FALSE         0.6 #> 6 5.24     40     1 FALSE         0.6 jpap_1 %>%    grim_map(items = 3) #> # A tibble: 6 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 5.90     40     3 TRUE         -0.2 #> 2 5.71     40     3 TRUE         -0.2 #> 3 3.50     40     3 TRUE         -0.2 #> 4 3.82     40     3 TRUE         -0.2 #> 5 4.61     40     3 TRUE         -0.2 #> 6 5.24     40     3 TRUE         -0.2 jpap_2 <- tribble(    ~x,    ~items,   \"6.92\",  1,   \"3.48\",  1,   \"1.59\",  2,   \"2.61\",  2,   \"4.04\",  3,   \"4.50\",  3, ) %>%    mutate(n = 30)  jpap_2 %>%    grim_map() #> # A tibble: 6 × 5 #>   x         n items consistency ratio #>   <chr> <int> <dbl> <lgl>       <dbl> #> 1 6.92     30     1 FALSE         0.7 #> 2 3.48     30     1 FALSE         0.7 #> 3 1.59     30     2 FALSE         0.4 #> 4 2.61     30     2 FALSE         0.4 #> 5 4.04     30     3 TRUE          0.1 #> 6 4.50     30     3 TRUE          0.1"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"percentage-conversion","dir":"Articles","previous_headings":"GRIM testing","what":"Percentage conversion","title":"GRIM","text":"underappreciated strength GRIM testing percentages. Since actually decimal numbers inflated factor 100, percentages come two “free” decimal places. However, percentages often reported decimal places beyond two, increases probability GRIM-inconsistencies unless true values correctly reported. grim() grim_map() percent parameter , set TRUE, divides x values 100 increases decimal count two, percentages can tested just like means:","code":"jpap_3 <- tribble(   ~x,     ~n,   \"32.5\",  438,   \"35.6\",  455,   \"21.7\",  501,   \"39.3\",  516, )  jpap_3 %>%    grim_map(percent = TRUE) #> ℹ `x` converted from percentage #> # A tibble: 4 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 0.325   438     1 FALSE       0.562 #> 2 0.356   455     1 TRUE        0.545 #> 3 0.217   501     1 FALSE       0.499 #> 4 0.393   516     1 TRUE        0.484"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"reconstructed-values","dir":"Articles","previous_headings":"GRIM testing","what":"Reconstructed values","title":"GRIM","text":"Set show_rec TRUE want values reconstructed GRIM-testing displayed output. columns prefixed rec_: additional columns — rec_sum: sum total mean proportion ostensibly derived. rec_x_upper: upper reconstructed x value. rec_x_lower: lower reconstructed x value. rec_x_upper_rounded_up: rec_x_upper value rounded . rec_x_upper_rounded_down: rec_x_upper value rounded . rec_x_lower_rounded_up: rec_x_lower value rounded . rec_x_lower_rounded_down: rec_x_lower value rounded . last four columns depend rounding. , follow default \"up_or_down\", leading two columns rec_x_upper rec_x_lower. singular rounding procedure, \"\", one column , thus, two total. difference numbers greatly important, however, rounding mostly delivers results. Internally, GRIM-consistency determined whether stated x value near-identical either rec_x_upper_rounded rec_x_lower_rounded. algorithm follows charitable conservative protocol outlined Brown Heathers (2017).","code":"pigs1 %>%    grim_map(show_rec = TRUE) #> # A tibble: 12 × 12 #>    x         n items consistency rec_sum rec_x_upper rec_x_lower #>    <chr> <int> <int> <lgl>         <dbl>       <dbl>       <dbl> #>  1 7.22     32     1 TRUE         231.          7.25       7.22  #>  2 4.74     25     1 FALSE        118.          4.76       4.72  #>  3 5.23     29     1 FALSE        152.          5.24       5.21  #>  4 2.57     24     1 FALSE         61.7         2.58       2.54  #>  5 6.77     27     1 FALSE        183.          6.78       6.74  #>  6 2.68     28     1 TRUE          75.0         2.71       2.68  #>  7 7.01     29     1 FALSE        203.          7.03       7     #>  8 7.38     26     1 TRUE         192.          7.38       7.35  #>  9 3.14     27     1 FALSE         84.8         3.15       3.11  #> 10 6.89     31     1 FALSE        214.          6.90       6.87  #> 11 5.00     25     1 TRUE         125           5          5     #> 12 0.24     28     1 FALSE          6.72        0.25       0.214 #> # … with 5 more variables: rec_x_upper_rounded_up <dbl>, #> #   rec_x_upper_rounded_down <dbl>, rec_x_lower_rounded_up <dbl>, #> #   rec_x_lower_rounded_down <dbl>, ratio <dbl>"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"rounding","dir":"Articles","previous_headings":"GRIM testing","what":"Rounding","title":"GRIM","text":"scrutiny package provides infrastructure reconstructing rounded numbers. can commanded within grim() grim_map(). Several parameters allow stating precise way original numbers supposedly rounded. First foremost rounding. takes string rounding procedure’s name, leads number rounded either ways: Rounded \"\" \"\" 5. Note SAS, SPSS, Stata, Matlab, Excel round \"\" 5, whereas Python rounds \"\" 5. Rounded \"even\" using base R’s round(). Rounded \"up_from\" \"down_from\" number, needs specified via threshold parameter. Given \"ceiling\" \"floor\" respective decimal place. Rounded towards zero \"trunc\" away zero \"anti_trunc\". default, \"up_or_down\", allows numbers rounded either \"\" \"\" 5 GRIM-testing; likewise \"up_from_or_down_from\" \"ceiling_or_floor\". procedures, see documentation round(), round_up(), round_ceiling(). include ways rounding. Points 3 5 list quite obscure options included cover wide spectrum possible rounding procedures. true threshold symmetric parameters, aren’t discussed . Learn scrutiny’s infrastructure rounding vignette(\"rounding\"). default, grim() grim_map() accept values rounded either 5. reason impose stricter assumptions way x rounded, specify rounding accordingly: Rounding leads precisely opposite results first two cases, although agrees latter two. Even example cherry-picked: Sample sizes 80 highly unusual , n values, two rounding procedures agree overwhelming majority cases. See section Visualizing results grim_plot() issue. might still important account different ways numbers can rounded, demonstrate given results robust variable decisions. err side caution, default rounding permissive \"up_or_down\".","code":"jpap_4 <- tibble::tribble(     ~x,     ~n,     \"2.02\",  80,     \"2.03\",  80,     \"2.04\",  80,     \"2.05\",  80, )  jpap_4 %>%    grim_map(rounding = \"up\") #> # A tibble: 4 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 2.02     80     1 FALSE         0.2 #> 2 2.03     80     1 TRUE          0.2 #> 3 2.04     80     1 TRUE          0.2 #> 4 2.05     80     1 TRUE          0.2  jpap_4 %>%    grim_map(rounding = \"down\") #> # A tibble: 4 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 2.02     80     1 TRUE          0.2 #> 2 2.03     80     1 FALSE         0.2 #> 3 2.04     80     1 TRUE          0.2 #> 4 2.05     80     1 TRUE          0.2"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"testing-numeric-sequences","dir":"Articles","previous_headings":"","what":"Testing numeric sequences","title":"GRIM","text":"Analysts might interested mean percentage value’s numeric neighborhood. Suppose found reported mean 5.30 GRIM-inconsistent sample size 32. might hypothesize swapped nearby correct value. two ways approach : (1) testing sequence vectors seq_distance() grim(), (2) testing sequence data frames seq_distance_df() grim_map(). think second way useful, see .","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"with-seq_distance-and-grim","dir":"Articles","previous_headings":"Testing numeric sequences","what":"With seq_distance() and grim()","title":"GRIM","text":"Create sequence starting 5.30 seq_distance() pipe result grim(), specify n 32. Although starting point allowed numeric, need enter 5.30 string preserve trailing zero:","code":"seq_distance(from = \"5.30\") %>%    grim(n = 32) #>  5.30  5.31  5.32  5.33  5.34  5.35  5.36  5.37  5.38  5.39  #> FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"with-seq_distance_df-and-grim_map","dir":"Articles","previous_headings":"Testing numeric sequences","what":"With seq_distance_df() and grim_map()","title":"GRIM","text":"First, use seq_distance_df() create data frame sequence column starting 5.30, adding n column ’s constant 32: data frame can readily piped grim_map(), get neat output table without much preparation: results, turn, can analyzed seq_test_ranking(): Read scrutiny’s four seq_* functions vignette(\"infrastructure\"); two left .","code":"seq_distance_df(.from = \"5.30\", n = 32) #> # A tibble: 10 × 2 #>    x         n #>    <chr> <dbl> #>  1 5.30     32 #>  2 5.31     32 #>  3 5.32     32 #>  4 5.33     32 #>  5 5.34     32 #>  6 5.35     32 #>  7 5.36     32 #>  8 5.37     32 #>  9 5.38     32 #> 10 5.39     32 seq_distance_df(.from = \"5.30\", n = 32) %>%    grim_map() #> # A tibble: 10 × 5 #>    x         n items consistency ratio #>    <chr> <int> <int> <lgl>       <dbl> #>  1 5.30     32     1 FALSE        0.68 #>  2 5.31     32     1 TRUE         0.68 #>  3 5.32     32     1 FALSE        0.68 #>  4 5.33     32     1 FALSE        0.68 #>  5 5.34     32     1 TRUE         0.68 #>  6 5.35     32     1 FALSE        0.68 #>  7 5.36     32     1 FALSE        0.68 #>  8 5.37     32     1 TRUE         0.68 #>  9 5.38     32     1 TRUE         0.68 #> 10 5.39     32     1 FALSE        0.68 seq_distance_df(.from = \"5.30\", n = 32) %>%    grim_map() %>%    seq_test_ranking() #>  #> Explanation: #> ℹ There are 4 consistent value sets, starting with row number 2 in the data #>   frame created by `grim_map()`. #> ℹ All other value sets are inconsistent. #> ℹ The consistent sets lag the inconsistent ones by numbers of places from 1 to #>   3 in the `grim_map()` data frame. #> # A tibble: 6 × 3 #>   consistent inconsistent lead_lag #>        <int>        <int>    <int> #> 1          2            1       -1 #> 2          5            3       -2 #> 3          8            4       -4 #> 4          9            6       -3 #> 5         NA            7       NA #> 6         NA           10       NA"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"summarizing-results-with-audit","dir":"Articles","previous_headings":"","what":"Summarizing results with audit()","title":"GRIM","text":"Following call grim_map(), generic function audit() summarizes GRIM test results: columns — incons_cases: number GRIM-inconsistent value sets. all_cases: total number value sets. incons_rate: proportion GRIM-inconsistent value sets. mean_ratio: average GRIM ratios. incons_base_ratio: ratio incons_rate mean_ratio. testable_cases: number GRIM-testable value sets (.e., positive ratio). testable_rate: proportion GRIM-testable value sets.","code":"flying_pigs1 %>%    grim_map() %>%    audit() #> # A tibble: 1 × 7 #>   incons_cases all_cases incons_rate mean_grim_ratio incons_to_ratio #>          <dbl>     <dbl>       <dbl>           <dbl>           <dbl> #> 1            3         7       0.429            0.72           0.595 #> # … with 2 more variables: testable_cases <dbl>, testable_rate <dbl>"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"visualizing-results-with-grim_plot","dir":"Articles","previous_headings":"","what":"Visualizing results with grim_plot()","title":"GRIM","text":"specialized visualization function GRIM test results, grim_plot():  grim_plot() can called grim_map()’s output. fail otherwise: sheer optics plot probably fit everyone’s taste. However, strictly based laws governing GRIM. background raster shows consistent (light) inconsistent (dark) value pairs two decimal places. Empirical values shown blue consistent red inconsistent. Color settings ggplot2-typical options available via arguments. Read grim_plot()’s documentation. might notice light vertical lines \\(N = 40\\) \\(N = 80\\): values flagged inconsistent . reflects grim_map()’s charitable default accepting values rounded either 5. different rounding specification chosen grim_map() call, plot raster adjust automatically:  rounding values up_from, down_from, up_from_or_down_from supported. Speed much concern rasters based data already stored within package (R/sysdata.rda), don’t need generated spot every time function called. See R/data-gen.R way generated.","code":"jpap_5 <- tribble(   ~x,        ~n,   \"7.19\",    28,   \"4.56\",    34,   \"0.42\",    27,   \"1.31\",    25,   \"3.48\",    34,   \"4.27\",    29,   \"6.21\",    30,   \"3.11\",    18,   \"5.39\",    36,   \"5.66\",    18, )   jpap_5 %>%    grim_map() %>%    grim_plot() mtcars %>%    grim_plot() #> Error: `data` is not `grim_map()` output #> ✖ `grim_plot()` needs GRIM test results. #> ℹ The only exception is an \"empty\" plot that shows the background raster but no #>   empirical test results. Create such a plot by setting `show_data` to `FALSE`. jpap_5 %>%    grim_map(rounding = \"up\") %>%    grim_plot()"},{"path":[]},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"formula","dir":"Articles","previous_headings":"GRIM statistics > The GRIM ratio","what":"Formula","title":"GRIM","text":"ratio column tibble returned grim_map() “GRIM ratio”, .e.: \\[ \\frac{10^D - NL}{10^D} \\] \\(D\\) number decimal places x (mean proportion), \\(N\\) sample size, \\(L\\) number scale items. \\(N, L \\geq 1\\), GRIM ratio ranges \\(-\\infty\\) \\(1 - \\frac{1}{10^D}\\), asymptotically approaching 1. upper bound 0.9 \\(D = 1\\) 0.99 \\(D = 2\\), etc.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"functions","dir":"Articles","previous_headings":"GRIM statistics > The GRIM ratio","what":"Functions","title":"GRIM","text":"grim_ratio() takes arguments x, n, items, percent grim() grim_map(): addition, grim_total() takes arguments returns numerator formula: grim_map()’s prob argument set TRUE, adds prob column shows probability GRIM inconsistency. prob derived left-censoring ratio column 0, equal ratio \\(0 \\leq ratio\\). \\(ratio < 0\\), \\(prob = 0\\). (GRIM ratio 1 greater.)","code":"grim_ratio(x = 1.42, n = 72) #> [1] 0.28  grim_ratio(x = 5.93, n = 80, items = 3) #> [1] -1.4  grim_ratio(x = \"84.20\", n = 40, percent = TRUE)  # Enter `x` as string to preserve trailing zero #> [1] 0.996 grim_total(x = 1.42, n = 72) #> [1] 28  grim_total(x = 5.93, n = 80, items = 3) #> [1] -140  grim_total(x = \"84.20\", n = 40, percent = TRUE)  # Enter `x` as string to preserve trailing zero #> [1] 9960"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"interpretation","dir":"Articles","previous_headings":"GRIM statistics > The GRIM ratio","what":"Interpretation","title":"GRIM","text":"GRIM ratio non-negative, can interpreted proportion inconsistent value sets corresponding given set parameters. also probability randomly chosen mean GRIM-inconsistent. ratio negative, probability 0. Similarly, grim_total() value non-negative, can interpreted total number GRIM inconsistencies corresponding given set parameters. negative, total 0.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"origins","dir":"Articles","previous_headings":"GRIM statistics > The GRIM ratio","what":"Origins","title":"GRIM","text":"Although term “GRIM ratio” new, formula arguably implicit Brown Heathers’ (2017) paper GRIM. numerator transformation formula presented p. 364, authors discuss common special case ratio (interpreted proportion) p. 367: reporting two decimal places, sample size \\(N < 100\\) [single item], random mean value consistent approximately \\(N\\)% cases. Assuming \\(N = 70\\) inserting values formula returns \\[ \\frac{10^2-70×1}{10^2} = 0.3 \\] random mean inconsistent 30% cases , conversely, consistent 70%. code (assuming arbitrary mean two decimal places): Thus, regarding GRIM ratio make general formula explicit give name. Researchers may judge useful analyses.","code":"grim_ratio(x = 0.99, n = 70) #> [1] 0.3"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"granularity-and-scale-items","dir":"Articles","previous_headings":"GRIM statistics","what":"Granularity and scale items","title":"GRIM","text":"distribution’s granularity minimal amount two means proportions non-continuous distribution can differ. derived sample size number scale items. number items, turn, naturally follows distribution’s sample size granularity.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"formulas","dir":"Articles","previous_headings":"GRIM statistics > Granularity and scale items","what":"Formulas","title":"GRIM","text":"granularity (\\(G\\)) formula \\[ G = \\frac{1}{NL} \\] \\(N\\) sample size \\(L\\) number items. scale items formula converse: \\[ L = \\frac{1}{NG} \\]","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"functions-1","dir":"Articles","previous_headings":"GRIM statistics > Granularity and scale items","what":"Functions","title":"GRIM","text":"Suppose ordinal distribution 80 observations five items. get granularity, run : Now, imagine distribution 50 observations granularity 0.01. get number items (actual effective), use code: number items granularity 1, call grim_items() doesn’t return whole numbers indicates problem earlier computations. warning effect displayed:","code":"grim_granularity(n = 80, items = 4) #> [1] 0.003125 grim_items(n = 50, gran = 0.01) #> [1] 2 grim_items(n = c(50, 65, 93), gran = 0.02) #> Warning: 2 item counts aren't whole numbers #> → This concerns 0.7692308 and 0.5376344. #> ! Item counts have a granularity of 1, so they should be whole numbers. Are you #>   sure about the `n` and `gran` values? #> [1] 1.0000000 0.7692308 0.5376344"},{"path":"https://lhdjung.github.io/scrutiny/articles/grim.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"GRIM","text":"Brown, Nicholas J. L., James . J. Heathers. 2017. “Grim Test: Simple Technique Detects Numerous Anomalies Reporting Results Psychology.” Social Psychological Personality Science 8 (4): 363–69. https://doi.org/10.1177/1948550616673876.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"count-decimal-places","dir":"Articles","previous_headings":"","what":"Count decimal places","title":"Infrastructure beyond rounding","text":"Large parts package ultimately rest either two functions simply count decimal places. digits number’s decimal point separator. functions also take strings. decimal_places() vectorized: Using strings coercible numeric recommended error detection context trailing zeros can crucial . Numeric values drop trailing zeros, whereas strings preserve : decimal_places_scalar() considerably faster decimal_places() takes single number string account. makes suitable helper within single-case functions.","code":"decimal_places(\"2.80\") #> [1] 2  decimal_places(c(55.1, 6.493, 8)) #> [1] 1 3 0  vec1 <- iris %>%    dplyr::slice(1:10) %>%    dplyr::pull(Sepal.Length)  vec1 #>  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9  vec1 %>%    decimal_places() #>  [1] 1 1 1 1 0 1 1 0 1 1 decimal_places(7.200) #> [1] 1  decimal_places(\"7.200\") #> [1] 3"},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"restore-trailing-zeros","dir":"Articles","previous_headings":"","what":"Restore trailing zeros","title":"Infrastructure beyond rounding","text":"dealing numbers used trailing zeros lost registered numeric, call restore_zeros() format correctly. can relevant within functions create vectors trailing zeros matter, seq_*() functions presented next section. Suppose following numbers originally one decimal place, longer : Now, get back restore_zeros(): uses default going longest mantissa padding strings decimal zeros many decimal places. However, just heuristic: longest mantissa might lost decimal places. Specify width argument explicitly state desired mantissa length:","code":"vec <- c(4, 6.9, 5, 4.2, 4.8, 7, 4)  vec %>%    decimal_places() #> [1] 0 1 0 1 1 0 0 vec %>%    restore_zeros() #> [1] \"4.0\" \"6.9\" \"5.0\" \"4.2\" \"4.8\" \"7.0\" \"4.0\"  vec %>%    restore_zeros() %>%    decimal_places() #> [1] 1 1 1 1 1 1 1 vec %>%    restore_zeros(width = 2) #> [1] \"4.00\" \"6.90\" \"5.00\" \"4.20\" \"4.80\" \"7.00\" \"4.00\"  vec %>%    restore_zeros(width = 2) %>%    decimal_places() #> [1] 2 2 2 2 2 2 2"},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"the-limits-of-seq","dir":"Articles","previous_headings":"Sequence generation","what":"The limits of seq()","title":"Infrastructure beyond rounding","text":"base::seq() elegant way generate regular sequences, almost elegant: way determine step size entirely depends arguments added non-standard evaluation (.e., via dots, …). default, step size assumed 1, can overridden using parameter. However, clashes way state desired output length, length.parameter. makes step size dependent , , , therefore highly variable face different specifications parameters. example: worth emphasizing seq() encapsulates two mutually exclusive ways generating sequences: (1) manually specified step size without controlling output length; (2) manually specified output length without controlling step size. two approaches overdetermine , therefore irreconcilable. ’s get try ways within single call: Another issue seq() doesn’t automatically take input numbers’ decimal depth account (.e., unless specified way), desirable error detection context. regards decimal sequences, therefore, seq() much little. two distinct functional rationales uneasily sit together single function. One might wish disentangle : generate sequences either run B appropriate decimal level, given length without jeopardizing step size. might even worth spelling two rationales distinct functions. happens, scrutiny features two wrappers around seq() separately capture modi operandi, guided input numbers’ decimal depth: seq_endpoint() seq_distance(). functions forsake argument, ’s actually good infer step size automatically number decimal places input values. package also two functions build basic ones quickly flexibly constructing data frames respective kind sequence, seq_endpoint_df() seq_distance_df(). latter two accept new columns entered tibble::tibble() dplyr::mutate(). , first present two basic seq() wrappers. Next, briefly discuss higher-level *_df functions.","code":"seq(from = 4, to = 7, length.out = 5) #> [1] 4.00 4.75 5.50 6.25 7.00  seq(from = 4, to = 20, length.out = 5) #> [1]  4  8 12 16 20 seq(from = 4, to = 7, by = 0.1, length.out = 5) #> Error in seq.default(from = 4, to = 7, by = 0.1, length.out = 5): too many arguments"},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"sequence-between-two-fix-points","dir":"Articles","previous_headings":"Sequence generation > Two seq() wrappers","what":"Sequence between two fix points","title":"Infrastructure beyond rounding","text":"Consider call seq(): intended output call likely sequence progresses steps 0.1, actually arrives 7. base::seq() won’t understand , scrutiny::seq_endpoint() : Unlike seq(), therefore, seq_endpoint() always reaches target. last value vector returned seq_endpoint() numerically equal value argument, matter arguments specified. (output string default, doesn’t need :) step size (\\(S\\)), function counts decimal places , looks greater number decimal places (\\(D_{max}\\)). proceeds one unit longer mantissa’s last decimal digit: \\[ S = \\frac{1}{10^{D_{max}}} \\] endpoint decimal places starting point, works like : step size seq_endpoint() determined greater decimal depth among main arguments, ’s possible set starting point /endpoint sequence level: also works negative offset values:","code":"seq(from = 4.1, to = 7) #> [1] 4.1 5.1 6.1 seq_endpoint(from = 4.1, to = 7) #>  [1] \"4.1\" \"4.2\" \"4.3\" \"4.4\" \"4.5\" \"4.6\" \"4.7\" \"4.8\" \"4.9\" \"5.0\" \"5.1\" \"5.2\" #> [13] \"5.3\" \"5.4\" \"5.5\" \"5.6\" \"5.7\" \"5.8\" \"5.9\" \"6.0\" \"6.1\" \"6.2\" \"6.3\" \"6.4\" #> [25] \"6.5\" \"6.6\" \"6.7\" \"6.8\" \"6.9\" \"7.0\" seq_endpoint(from = 4.1, to = 7, string_output = FALSE) #>  [1] 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 5.0 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 #> [20] 6.0 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 7.0 seq_endpoint(from = 4.5, to = 4.62) #>  [1] \"4.50\" \"4.51\" \"4.52\" \"4.53\" \"4.54\" \"4.55\" \"4.56\" \"4.57\" \"4.58\" \"4.59\" #> [11] \"4.60\" \"4.61\" \"4.62\" seq_endpoint(from = 0, to = 0.5)                    # no offset #> [1] \"0.0\" \"0.1\" \"0.2\" \"0.3\" \"0.4\" \"0.5\"  seq_endpoint(from = 0, to = 0.5, offset_from = 3)   # start at 0.3 instead of 0 #> [1] \"0.3\" \"0.4\" \"0.5\"  seq_endpoint(from = 0, to = 0.5, offset_to = 3)     # end at 0.8 instead of 0.5 #> [1] \"0.0\" \"0.1\" \"0.2\" \"0.3\" \"0.4\" \"0.5\" \"0.6\" \"0.7\" \"0.8\" seq_endpoint(from = 0, to = 0.5, offset_from = -3)   # start at -0.3 instead of 0 #> [1] \"-0.3\" \"-0.2\" \"-0.1\" \"0.0\"  \"0.1\"  \"0.2\"  \"0.3\"  \"0.4\"  \"0.5\"  seq_endpoint(from = 0, to = 0.5, offset_to = -3)     # end at 0.2 instead of 0.5 #> [1] \"0.0\" \"0.1\" \"0.2\""},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"sequence-of-stated-length","dir":"Articles","previous_headings":"Sequence generation > Two seq() wrappers","what":"Sequence of stated length","title":"Infrastructure beyond rounding","text":"seq_distance() doesn’t take argument — takes starting point generates sequence . length can chosen , sequence always proceeds one unit ’s last decimal digit: default length 10: Reverse direction dir = -1: Offsetting starting point works seq_endpoint(), although offset_to argument:","code":"seq_distance(from = 8, length_out = 5) #> [1] \"8\"  \"9\"  \"10\" \"11\" \"12\"  seq_distance(from = 3.2, length_out = 5) #> [1] \"3.2\" \"3.3\" \"3.4\" \"3.5\" \"3.6\" seq_distance(29.97) #>  [1] \"29.97\" \"29.98\" \"29.99\" \"30.00\" \"30.01\" \"30.02\" \"30.03\" \"30.04\" \"30.05\" #> [10] \"30.06\" seq_distance(from = 2.7, dir = -1) #>  [1] \"2.7\" \"2.6\" \"2.5\" \"2.4\" \"2.3\" \"2.2\" \"2.1\" \"2.0\" \"1.9\" \"1.8\" seq_distance(from = 2.7, offset_from = 4) #>  [1] \"3.1\" \"3.2\" \"3.3\" \"3.4\" \"3.5\" \"3.6\" \"3.7\" \"3.8\" \"3.9\" \"4.0\"  seq_distance(from = 2.7, offset_from = -4) #>  [1] \"2.3\" \"2.4\" \"2.5\" \"2.6\" \"2.7\" \"2.8\" \"2.9\" \"3.0\" \"3.1\" \"3.2\""},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"data-frames-with-sequence-columns","dir":"Articles","previous_headings":"Sequence generation","what":"Data frames with sequence columns","title":"Infrastructure beyond rounding","text":"seq_* functions seq_*_df() variant. meant interactive analysis, e.g., GRIM-testing neighbors inconsistent value. New columns can created within call tibble::tibble() dplyr::mutate(). arguments basic functions available, dot . Output functions correct format scrutiny’s data frame testing functions like grim_map(). See vignette(\"grim\"), section Testing numeric sequences. endpoint data frame variant, extra column added: distance data frame variant:","code":"seq_endpoint_df(.from = \"4.50\", .to = 4.57, n = 30) #> # A tibble: 8 × 2 #>   x         n #>   <chr> <dbl> #> 1 4.50     30 #> 2 4.51     30 #> 3 4.52     30 #> 4 4.53     30 #> 5 4.54     30 #> 6 4.55     30 #> 7 4.56     30 #> 8 4.57     30 seq_distance_df(.from = \"4.50\", .length_out = 5, n = 30) #> # A tibble: 5 × 2 #>   x         n #>   <chr> <dbl> #> 1 4.50     30 #> 2 4.51     30 #> 3 4.52     30 #> 4 4.53     30 #> 5 4.54     30"},{"path":"https://lhdjung.github.io/scrutiny/articles/infrastructure.html","id":"test-for-subsets-supersets-and-equal-sets","dir":"Articles","previous_headings":"","what":"Test for subsets, supersets, and equal sets","title":"Infrastructure beyond rounding","text":"Starting is_subset_of(), scrutiny features distinctive family predicate functions test whether one vector x subset another vector y, whether x superset y (.e. reverse subset), whether x y equal sets. teaser: functions divided three subgroups based way second vector, y, constituted. example, might test x subset multiple vectors taken together, superset vector y consists multiple values entered along x. Functions family currently used helpers inside scrutiny functions, may well change. Use elsewhere also conceivable.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Rounding","text":"Base R’s round() function surprisingly sophisticated, distinguishes simple ways decimal numbers normally rounded — time, rounding 5. reason, however, can’t used reconstruct rounding procedures software programs. job scrutiny’s rounding functions. First, present reround(), general interface reconstructing rounded numbers, going individual rounding functions. add comments . also discuss unround(), works reverse way: takes rounded number reconstructs bounds original number, taking details assumed rounding procedure account. Finally, take closer look bias rounding raw numbers.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"reconstruct-rounded-numbers-with-reround","dir":"Articles","previous_headings":"","what":"Reconstruct rounded numbers with reround()","title":"Rounding","text":"None error detection techniques scrutiny calls individual rounding functions directly. Instead, call reround(), mediates two levels. reround() takes vector “raw” reconstructed numbers yet rounded way ’s assumed original rounding procedure. next argument digits, number decimal places round . remaining three arguments rounding procedure. time, rounding interest. takes string name one rounding procedures discussed . example reround() call: two remaining arguments mostly forgettable: concern obscure cases rounding threshold 5 (threshold) rounding absolute values positive negative numbers (symmetric). Ignore otherwise.","code":"reround(x = c(5.812, 7.249), digits = 2, rounding = \"up\") #> [1] 5.81 7.25"},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"up-and-down","dir":"Articles","previous_headings":"Rounding procedures in detail","what":"Up and down","title":"Rounding","text":"round_up() people think rounding. decimal portion cut rounding 5 greater, rounds . Otherwise, rounds . SAS, SPSS, Stata, Matlab, Excel use procedure. Rounding 5 actually special case round_up_from(), can take numeric threshold, just 5: two functions mirror images round_down() round_down_from(). Like round_down(), Python rounds 5. arguments round_up(): round_down_from(), , just reverse round_up_from():","code":"round_up(x = 1.24, digits = 1) #> [1] 1.2  round_up(x = 1.25, digits = 1) #> [1] 1.3  round_up(x = 1.25)  # default for `digits` is 0 #> [1] 1 round_up_from(x = 4.28, digits = 1, threshold = 9) #> [1] 4.2  round_up_from(x = 4.28, digits = 1, threshold = 1) #> [1] 4.3 round_down(x = 1.24, digits = 1) #> [1] 1.2  round_down(x = 1.25, digits = 1) #> [1] 1.2  round_down(x = 1.25)  # default for `digits` is 0 #> [1] 1 round_down_from(x = 4.28, digits = 1, threshold = 9) #> [1] 4.3  round_down_from(x = 4.28, digits = 1, threshold = 1) #> [1] 4.2"},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"to-even-base-r","dir":"Articles","previous_headings":"Rounding procedures in detail","what":"To even (base R)","title":"Rounding","text":"Base R’s rounding function outlier statistical computing. base::round() doesn’t round , use procedure based solely removed part number. Instead, round() strives round next even number. (also called “banker’s rounding”.) Realizing round() works highly unintuitive way sometimes leads consternation. can’t just round like learned school, , 5? reason seems bias. 5 right two whole numbers, procedure rounds 5 predetermined direction introduces bias toward direction. Rounding 5 therefore biased upward, rounding 5 biased downward. shown Rounding bias section , unlikely major issue rounding raw numbers originally many decimal places. might serious, however, initial number decimal places low (whatever reason) need precision high. least theory, “rounding even” biased either direction, mean rounded distribution equal mean original distribution. round() aims operate. case works , whereas bias rounding fully apparent: formal take issue can found Rounding bias. However, noble goal unbiased rounding runs reality floating point computations. might therefore get results round() first seem bizarre, least unpredictable. Consider: Sometimes round() behaves just , times, results can hard explain. Martin Mächler, wrote present version round(), describes issue follows (https://cran.r-project.org/web/packages/round/vignettes/Rounding.html): reason behavior decimal fractions can’t, fact, represented double precision numbers. Even seemingly clean numbers decimal places come invisible mantissa, therefore closer one side . Rounding even R, ostensibly breaking tie occurs 5, actually much measuring two sides closer number rounded. seems better going mathematical intuitions sometimes may little relation way computers actually deal issues. R using present solution since version 4.0.0. effect, base::round() black box, seems unbiased long run. recommend using round() original work — even though quite different rounding procedures, therefore unsuitable reconstructing . Instead, need something like scrutiny’s round_* functions.","code":"vec1 <- seq(from = 0.5, to = 9.5) up1 <- round_up(vec1) down1 <- round_down(vec1) even1 <- round(vec1)  vec1 #>  [1] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 up1 #>  [1]  1  2  3  4  5  6  7  8  9 10 down1 #>  [1] 0 1 2 3 4 5 6 7 8 9 even1 #>  [1]  0  2  2  4  4  6  6  8  8 10  # Original mean mean(vec1) #> [1] 5  # Means when rounding up or down: bias! mean(up1) #> [1] 5.5 mean(down1) #> [1] 4.5  # Mean when rounding to even: no bias mean(even1) #> [1] 5 vec2 <- seq(from = 4.5, to = 10.5)  up2 <- round_up(vec2) down2 <- round_down(vec2) even2 <- round(vec2)  vec1 #>  [1] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 up2 #> [1]  5  6  7  8  9 10 11 down2 #> [1]  4  5  6  7  8  9 10 even2  # No symmetry here... #> [1]  4  6  6  8  8 10 10  mean(vec2) #> [1] 7.5 mean(up2) #> [1] 8 mean(down2) #> [1] 7 mean(even2)  # ... and the mean is biased downward! #> [1] 7.428571   vec3 <- c(   1.05, 1.15, 1.25, 1.35, 1.45,   1.55, 1.65, 1.75, 1.85, 1.95 )  # This seems fine... vec3 %>%    round(1) #>  [1] 1.0 1.1 1.2 1.4 1.4 1.6 1.6 1.8 1.9 2.0  # ...but this doesn't: vec3 %>%    `+`(1) %>%    round(1) #>  [1] 2.0 2.1 2.2 2.4 2.5 2.5 2.6 2.8 2.9 3.0"},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"reconstruct-rounding-bounds-with-unround","dir":"Articles","previous_headings":"","what":"Reconstruct rounding bounds with unround()","title":"Rounding","text":"Rounding deletes information. mantissa cut part full, resulting number underdetermined respect original number: latter can’t inferred former. might interest, however, compute range original number given rounded number (especially number decimal places rounded) presumed rounding method. ’s often easy infer range, might also also useful general function use helper another function analyzing reported numbers. function unround(). returns lower upper bounds, says whether bounds inclusive — something varies greatly rounding procedure. Currently, unround() used helper within scrutiny’s DEBIT implementation; see vignette(\"debit\"). default rounding procedure unround() \"up_or_down\": complete list featured rounding procedures, see documentation unround(), section Rounding. left, range column displays pithy graphical overview columns (except rounding) order: lower lower bound original number. incl_lower TRUE lower bound inclusive FALSE otherwise. x input value. incl_upper TRUE upper bound inclusive FALSE otherwise. upper upper bound original number. default, decimal places counted internally function always operates appropriate decimal level. creates need take trailing zeros account, x needs string: Alternatively, function uses unround() helper might count decimal places (.e., internally calling decimal_places()). pass numbers unround() via decimals argument instead letting redundantly count decimal places second time. case, x can numeric trailing zeros longer needed. (, turn, responsibility count decimal places number-strings rather numeric values shifts unround() higher-level function.) following call returns exact tibble : Since x vectorized, might test several reported numbers :","code":"unround(x = \"8.0\") #> # A tibble: 1 × 7 #>   range                  rounding   lower incl_lower x     incl_upper upper #>   <chr>                  <chr>      <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 7.95 <= x(8.0) <= 8.05 up_or_down  7.95 TRUE       8.0   TRUE        8.05 unround(x = \"3.50\", rounding = \"up\") #> # A tibble: 1 × 7 #>   range                    rounding lower incl_lower x     incl_upper upper #>   <chr>                    <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.495 <= x(3.50) < 3.505 up        3.50 TRUE       3.50  FALSE       3.50 unround(x = 3.5, digits = 2, rounding = \"up\") #> # A tibble: 1 × 7 #>   range                   rounding lower incl_lower     x incl_upper upper #>   <chr>                   <chr>    <dbl> <lgl>      <dbl> <lgl>      <dbl> #> 1 3.495 <= x(3.5) < 3.505 up        3.50 TRUE         3.5 FALSE       3.50 vec2 <- c(2, 3.1, 3.5) %>%    restore_zeros()  vec2   # `restore_zeros()` returns \"2.0\" for 2 #> [1] \"2.0\" \"3.1\" \"3.5\"  vec2 %>%    unround(rounding = \"even\") #> # A tibble: 3 × 7 #>   range                rounding lower incl_lower x     incl_upper upper #>   <chr>                <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 1.95 < x(2.0) < 2.05 even      1.95 FALSE      2.0   FALSE       2.05 #> 2 3.05 < x(3.1) < 3.15 even      3.05 FALSE      3.1   FALSE       3.15 #> 3 3.45 < x(3.5) < 3.55 even      3.45 FALSE      3.5   FALSE       3.55"},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"fractional-rounding","dir":"Articles","previous_headings":"","what":"Fractional rounding","title":"Rounding","text":"want round numbers fraction instead integer? Check reround_to_fraction() reround_to_fraction_level(): function rounds 0.4 0.5 ’s closest fraction 2. inspired janitor::round_to_fraction(), credit core implementation goes . reround_to_fraction() blends fractional rounding flexibility precision reround() provides. ’s , reround_to_fraction_level() rounds nearest fraction decimal level specified via digits argument: two functions currently part error detection workflow.","code":"reround_to_fraction(x = 0.4, denominator = 2, rounding = \"up\") #> [1] 0.5 reround_to_fraction_level(   x = 0.777, denominator = 5, digits = 0, rounding = \"down\" ) #> [1] 0.8 reround_to_fraction_level(   x = 0.777, denominator = 5, digits = 1, rounding = \"down\" ) #> [1] 0.78 reround_to_fraction_level(   x = 0.777, denominator = 5, digits = 2, rounding = \"down\" ) #> [1] 0.776"},{"path":"https://lhdjung.github.io/scrutiny/articles/rounding.html","id":"rounding-bias","dir":"Articles","previous_headings":"","what":"Rounding bias","title":"Rounding","text":"wrote rounding 5 biased. However, points wider problem: true rounding procedure doesn’t take active precautions bias. base::round() , recommend original work (opposed reconstruction). might useful general flexible way quantify far rounding biases distribution, compared looked like rounding. function rounding_bias() fulfills role. wrapper around reround(), can access rounding procedure reround() can, takes arguments. However, default rounding \"\" instead \"up_or_down\" rounding_bias() makes sense single rounding procedures. general, bias due rounding computed subtracting original distribution rounded one: \\[ bias = x_{rounded} - x \\] default, mean computed reduce bias single data point: Set mean FALSE return whole vector individual biases instead: Admittedly, example somewhat overdramatic. rather harmless one: responsible difference? seems (1) sample size (2) number decimal places vector rounded. rounding method doesn’t appear matter numbers many decimal places rounded:  However, raw values preliminarily rounded 2 decimal places rounding proceeds , picture different. spare code time:  sum, function allows users quantify degree rounding biases distribution, can assess relative merits different rounding procedures. partly sensitize readers potential bias edge cases, also enable make informed rounding decisions .","code":"vec3 <- seq(from = 0.6, to = 0.7, by = 0.01)  vec3 #>  [1] 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70  # The mean before rounding... mean(vec3) #> [1] 0.65  # ...is not the same as afterwards... mean(round_up(vec3)) #> [1] 1  # ...and the difference is bias: rounding_bias(x = vec3, digits = 0, rounding = \"up\") #> [1] 0.35 rounding_bias(x = vec3, digits = 0, rounding = \"up\", mean = FALSE) #>  [1] 0.40 0.39 0.38 0.37 0.36 0.35 0.34 0.33 0.32 0.31 0.30 vec4 <- rnorm(50000, 100, 15)  rounding_bias(vec4, digits = 2) #> [1] -1.366715e-06 up_1   <- rounding_bias(vec4, digits = 1, rounding = \"up\") up_2   <- rounding_bias(vec4, digits = 2, rounding = \"up\") up_3   <- rounding_bias(vec4, digits = 3, rounding = \"up\") up_4   <- rounding_bias(vec4, digits = 4, rounding = \"up\") up_5   <- rounding_bias(vec4, digits = 5, rounding = \"up\")  even_1 <- rounding_bias(vec4, digits = 1, rounding = \"even\") even_2 <- rounding_bias(vec4, digits = 2, rounding = \"even\") even_3 <- rounding_bias(vec4, digits = 3, rounding = \"even\") even_4 <- rounding_bias(vec4, digits = 4, rounding = \"even\") even_5 <- rounding_bias(vec4, digits = 5, rounding = \"even\")   bias <- abs(c(   up_1, up_2, up_3, up_4, up_5,   even_1, even_2, even_3, even_4, even_5 ))  dp <- rep(1:5, 2) rounding <- c(rep(\"(up)\", 5), rep(\"(even)\", 5))  dp <- paste(dp, rounding)  df <- tibble::tibble(bias, dp, rounding)  # Display simulated data: df #> # A tibble: 10 × 3 #>             bias dp       rounding #>            <dbl> <chr>    <chr>    #>  1 0.000139      1 (up)   (up)     #>  2 0.00000137    2 (up)   (up)     #>  3 0.000000547   3 (up)   (up)     #>  4 0.000000307   4 (up)   (up)     #>  5 0.00000000368 5 (up)   (up)     #>  6 0.000139      1 (even) (even)   #>  7 0.00000137    2 (even) (even)   #>  8 0.000000547   3 (even) (even)   #>  9 0.000000307   4 (even) (even)   #> 10 0.00000000368 5 (even) (even)  `%+replace%` <- ggplot2::`%+replace%`  # Set ggplot2 theme for the remaining part of the session: ggplot2::theme_minimal(base_size = 12) %+replace%     ggplot2::theme(     panel.grid.major.x = ggplot2::element_blank(),     panel.grid.minor.x = ggplot2::element_blank(),     legend.position = \"none\"   ) %>%    ggplot2::theme_set()  # Visualize: ggplot2::ggplot(df, ggplot2::aes(x = dp, y = bias,                                  fill = rounding)) +   ggplot2::geom_col(ggplot2::aes(fill = rounding)) +   ggplot2::scale_y_continuous(expand = ggplot2::expansion(add = c(0, 0))                               # labels = scales::comma                               ) +   ggplot2::scale_fill_discrete(name = \"Rounding\") +   ggplot2::labs(     x = \"Decimal places (rounding procedure)\",     y = \"Mean absolute bias\",     title = \"Directly from random numbers\",     subtitle = \"Raw \\\"data\\\" mostly have 12 or 13 decimal places \"   ) #> # A tibble: 10 × 3 #>         bias dp       rounding #>        <dbl> <chr>    <chr>    #>  1 0.00507   1 (up)   (up)     #>  2 0         2 (up)   (up)     #>  3 0         3 (up)   (up)     #>  4 0         4 (up)   (up)     #>  5 0         5 (up)   (up)     #>  6 0.0000916 1 (even) (even)   #>  7 0         2 (even) (even)   #>  8 0         3 (even) (even)   #>  9 0         4 (even) (even)   #> 10 0         5 (even) (even)"},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"motivation","dir":"Articles","previous_headings":"Trailing zeros","what":"Motivation","title":"Data wrangling","text":"One particular challenge looking numeric irregularities R numbers often treated strings. reason R drops trailing zeros number registers object numeric value. major problem trailing zeros important , e.g., GRIM DEBIT trailing digits . solution know work strings — namely, strings can converted non-NA numeric values. present two ways work : (1) directly entering importing numbers strings, (2) restoring trailing zeros.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"with-tabulizer","dir":"Articles","previous_headings":"Trailing zeros > Enter numbers as strings","what":"With tabulizer","title":"Data wrangling","text":"tabulizer package way automatically extract tables PDF. Using tabulizer requires Java installed. works well, tabulizer great tool importing tables quickly efficiently. automatically captures values strings, trailing zeros treated just like digits. (See , Replace column names row values, solution issue can occur tabulizer.) However, tabulizer currently seem reliable enough focus importing tables. likely fault PDF format inbuilt support tables, effort extract faces serious ambiguities. many tables multiple files formatted way, can useful check tabulizer reliably accurately captures . doesn’t, might use copy paste.","code":""},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"with-copy-and-paste","dir":"Articles","previous_headings":"Trailing zeros > Enter numbers as strings","what":"With copy and paste","title":"Data wrangling","text":"Perhaps R users know RStudio features option multiple cursors. especially useful conjunction tibble::tribble(), available via scrutiny. ’s use multiple cursors present context: Copy column numbers PDF, pressing holding Alt Windows option Mac. (works least Adobe Acrobat.) Paste tribble() call . Pressing holding Alt/option, select copied numbers. Enter quotation marks , tribble()’s syntax, comma. get something like : ’s missing sample size. Add either via another tribble() column via dplyr::mutate(), also comes scrutiny:","code":"flights1 <- tribble(   ~x, \"8.97\", \"2.61\", \"7.26\", \"3.64\", \"9.26\", \"10.46\", \"7.39\", ) flights1 <- flights1 %>%    mutate(n = 28)  flights1 #> # A tibble: 7 × 2 #>   x         n #>   <chr> <dbl> #> 1 8.97     28 #> 2 2.61     28 #> 3 7.26     28 #> 4 3.64     28 #> 5 9.26     28 #> 6 10.46    28 #> 7 7.39     28"},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"restore-trailing-zeros","dir":"Articles","previous_headings":"Trailing zeros","what":"Restore trailing zeros","title":"Data wrangling","text":"dealing numbers used trailing zeros lost registered numeric, call restore_zeros() format correctly. Suppose following numbers originally one decimal place, longer : Now, get back restore_zeros(): uses default going longest mantissa padding strings decimal zeros many decimal places. However, just heuristic: longest mantissa might lost decimal places. Specify width argument explicitly state desired mantissa length:","code":"vec <- c(4, 6.9, 5, 4.2, 4.8, 7, 4)  vec %>%    decimal_places() #> [1] 0 1 0 1 1 0 0 vec %>%    restore_zeros() #> [1] \"4.0\" \"6.9\" \"5.0\" \"4.2\" \"4.8\" \"7.0\" \"4.0\"  vec %>%    restore_zeros() %>%    decimal_places() #> [1] 1 1 1 1 1 1 1 vec %>%    restore_zeros(width = 2) #> [1] \"4.00\" \"6.90\" \"5.00\" \"4.20\" \"4.80\" \"7.00\" \"4.00\"  vec %>%    restore_zeros(width = 2) %>%    decimal_places() #> [1] 2 2 2 2 2 2 2"},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"basic-usage","dir":"Articles","previous_headings":"Split strings by parentheses","what":"Basic usage","title":"Data wrangling","text":"summary data copied extracted PDF (see ), might encounter values presented like 5.22 (0.73). Instead manually teasing apart, call split_by_parens(): Optionally, transform values useful format: , can call debit_map() right away (supposing deal binary distributions’ means standard deviations):","code":"flights2 <- tribble(   ~drone,           ~selfpilot,   \"0.09 (0.21)\",    \"0.19 (0.13)\",   \"0.19 (0.28)\",    \"0.53 (0.10)\",   \"0.62 (0.16)\",    \"0.50 (0.11)\",   \"0.15 (0.35)\",    \"0.57 (0.16)\", )  flights2 %>%    split_by_parens() #> # A tibble: 4 × 4 #>   drone_x drone_sd selfpilot_x selfpilot_sd #>   <chr>   <chr>    <chr>       <chr>        #> 1 0.09    0.21     0.19        0.13         #> 2 0.19    0.28     0.53        0.10         #> 3 0.62    0.16     0.50        0.11         #> 4 0.15    0.35     0.57        0.16 flights2 %>%    split_by_parens(.transform = TRUE) #> # A tibble: 8 × 3 #>   .origin   x     sd    #>   <chr>     <chr> <chr> #> 1 drone     0.09  0.21  #> 2 drone     0.19  0.28  #> 3 drone     0.62  0.16  #> 4 drone     0.15  0.35  #> 5 selfpilot 0.19  0.13  #> 6 selfpilot 0.53  0.10  #> 7 selfpilot 0.50  0.11  #> 8 selfpilot 0.57  0.16 flights2 %>%    split_by_parens(.transform = TRUE) %>%    debit_map(n = 80) #> # A tibble: 8 × 11 #>   x     sd        n consistency rounding   sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>         <dbl> <lgl>            <dbl> #> 1 0.09  0.21     80 FALSE       up_or_down    0.205 TRUE             0.215 #> 2 0.19  0.28     80 FALSE       up_or_down    0.275 TRUE             0.285 #> 3 0.62  0.16     80 FALSE       up_or_down    0.155 TRUE             0.165 #> 4 0.15  0.35     80 TRUE        up_or_down    0.345 TRUE             0.355 #> 5 0.19  0.13     80 FALSE       up_or_down    0.125 TRUE             0.135 #> 6 0.53  0.10     80 FALSE       up_or_down    0.095 TRUE             0.105 #> 7 0.50  0.11     80 FALSE       up_or_down    0.105 TRUE             0.115 #> 8 0.57  0.16     80 FALSE       up_or_down    0.155 TRUE             0.165 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl>"},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"column-name-suffixes","dir":"Articles","previous_headings":"Split strings by parentheses","what":"Column name suffixes","title":"Data wrangling","text":"defaults column name suffixes (1) \"x\" part parentheses (2) \"sd\" part inside . However, won’t fit data presented like 5.22 (0.73). Override defaults specifying .col1 /.col2: suffixes become column names .transform set TRUE:","code":"flights2 %>%    split_by_parens(.col1 = \"beta\", .col2 = \"se\") #> # A tibble: 4 × 4 #>   drone_beta drone_se selfpilot_beta selfpilot_se #>   <chr>      <chr>    <chr>          <chr>        #> 1 0.09       0.21     0.19           0.13         #> 2 0.19       0.28     0.53           0.10         #> 3 0.62       0.16     0.50           0.11         #> 4 0.15       0.35     0.57           0.16 flights2 %>%    split_by_parens(.col1 = \"beta\", .col2 = \"se\", .transform = TRUE) #> # A tibble: 8 × 3 #>   .origin   beta  se    #>   <chr>     <chr> <chr> #> 1 drone     0.09  0.21  #> 2 drone     0.19  0.28  #> 3 drone     0.62  0.16  #> 4 drone     0.15  0.35  #> 5 selfpilot 0.19  0.13  #> 6 selfpilot 0.53  0.10  #> 7 selfpilot 0.50  0.11  #> 8 selfpilot 0.57  0.16"},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"extract-substrings-from-before_parens-and-inside_parens","dir":"Articles","previous_headings":"Split strings by parentheses","what":"Extract substrings from before_parens() and inside_parens()","title":"Data wrangling","text":"also specific functions extracting parts individual string vectors inside parentheses:","code":"flights3 <- flights2 %>%    dplyr::pull(selfpilot)  flights3 #> [1] \"0.19 (0.13)\" \"0.53 (0.10)\" \"0.50 (0.11)\" \"0.57 (0.16)\"  flights3 %>%    before_parens() #> [1] \"0.19\" \"0.53\" \"0.50\" \"0.57\"  flights3 %>%    inside_parens() #> [1] \"0.13\" \"0.10\" \"0.11\" \"0.16\""},{"path":"https://lhdjung.github.io/scrutiny/articles/wrangling.html","id":"replace-column-names-by-row-values","dir":"Articles","previous_headings":"","what":"Replace column names by row values","title":"Data wrangling","text":"extracting tables PDF tabulizer, might get data frames (converted matrices) wrong, nondescript column names, correct column names stored one rows within data frame . issue occurs across many similar tables correctly imported otherwise, becomes significant obstacle. first simulate problem. x n column names, instead values first row: remedy issue, call row_to_colnames() data frame. replace column names values one rows. latter specified position numbers dplyr::slice(). numbers, default 1 column names often stored first row, . specified row rows dropped shouldn’t rows first place. example: Note n still string vector, true columns tables extracted tabulizer.","code":"flights1_with_issues <- flights1 %>%      mutate(n = as.character(n)) %>%      tibble::add_row(x = \"x\", n = \"n\", .before = 1)  colnames(flights1_with_issues) <- c(\"Var1\", \"Var2\")  flights1_with_issues #> # A tibble: 8 × 2 #>   Var1  Var2  #>   <chr> <chr> #> 1 x     n     #> 2 8.97  28    #> 3 2.61  28    #> 4 7.26  28    #> 5 3.64  28    #> 6 9.26  28    #> 7 10.46 28    #> 8 7.39  28 flights1_with_issues %>%    row_to_colnames() #> # A tibble: 7 × 2 #>   x     n     #>   <chr> <chr> #> 1 8.97  28    #> 2 2.61  28    #> 3 7.26  28    #> 4 3.64  28    #> 5 9.26  28    #> 6 10.46 28    #> 7 7.39  28"},{"path":"https://lhdjung.github.io/scrutiny/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lukas Jung. Author, maintainer.","code":""},{"path":"https://lhdjung.github.io/scrutiny/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jung L (2022). scrutiny: Error Detection Science. https://github.com/lhdjung/scrutiny, https://lhdjung.github.io/scrutiny.","code":"@Manual{,   title = {scrutiny: Error Detection in Science},   author = {Lukas Jung},   year = {2022},   note = {https://github.com/lhdjung/scrutiny, https://lhdjung.github.io/scrutiny}, }"},{"path":"https://lhdjung.github.io/scrutiny/index.html","id":"error-detection-in-science","dir":"","previous_headings":"","what":"Error detection in science","title":"Error detection in science","text":"goal scrutiny test published summary statistics consistency reconstruct processes created . package makes methods easy use tidyverse-friendly way. hopes help new field error detection go mainstream. Besides consistency tests, scrutiny features infrastructure implementing error detection techniques, well specialized data wrangling functions. See Articles tab vignettes. scrutiny work progress. welcome contribute pull requests. However, please open issue first. package CRAN yet. can install GitHub like :","code":"remotes::install_github(\"lhdjung/scrutiny\")"},{"path":"https://lhdjung.github.io/scrutiny/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get started","title":"Error detection in science","text":"GRIM-test values data frame. using grim_map(), consistency column tells means (x), sample sizes (n), numbers scale items mutually consistent. Scale item numbers 1 default. Test percentages instead means: Visualize GRIM results also selecting rounding procedure:  Similarly, use DEBIT test means standard deviations binary data:","code":"library(scrutiny)  # Example data: pigs1 #> # A tibble: 12 × 2 #>    x         n #>    <chr> <dbl> #>  1 7.22     32 #>  2 4.74     25 #>  3 5.23     29 #>  4 2.57     24 #>  5 6.77     27 #>  6 2.68     28 #>  7 7.01     29 #>  8 7.38     26 #>  9 3.14     27 #> 10 6.89     31 #> 11 5.00     25 #> 12 0.24     28  # GRIM-testing for data frames: grim_map(pigs1) #> # A tibble: 12 × 5 #>    x         n items consistency ratio #>    <chr> <int> <int> <lgl>       <dbl> #>  1 7.22     32     1 TRUE         0.68 #>  2 4.74     25     1 FALSE        0.75 #>  3 5.23     29     1 FALSE        0.71 #>  4 2.57     24     1 FALSE        0.76 #>  5 6.77     27     1 FALSE        0.73 #>  6 2.68     28     1 TRUE         0.72 #>  7 7.01     29     1 FALSE        0.71 #>  8 7.38     26     1 TRUE         0.74 #>  9 3.14     27     1 FALSE        0.73 #> 10 6.89     31     1 FALSE        0.69 #> 11 5.00     25     1 TRUE         0.75 #> 12 0.24     28     1 FALSE        0.72 pigs2 #> # A tibble: 6 × 2 #>   x         n #>   <chr> <dbl> #> 1 67.4    150 #> 2 54.2    150 #> 3 54.0    150 #> 4 69.8    150 #> 5 68.1    150 #> 6 55.4    150  grim_map(pigs2, percent = TRUE) #> ℹ `x` converted from percentage #> # A tibble: 6 × 5 #>   x         n items consistency ratio #>   <chr> <int> <int> <lgl>       <dbl> #> 1 0.674   150     1 FALSE        0.85 #> 2 0.542   150     1 FALSE        0.85 #> 3 0.540   150     1 TRUE         0.85 #> 4 0.698   150     1 FALSE        0.85 #> 5 0.681   150     1 FALSE        0.85 #> 6 0.554   150     1 FALSE        0.85 pigs1 %>%    grim_map(rounding = \"up\") %>%    grim_plot() pigs3 #> # A tibble: 7 × 3 #>   x     sd        n #>   <chr> <chr> <dbl> #> 1 0.53  0.50   1683 #> 2 0.44  0.50   1683 #> 3 0.77  0.42   1683 #> 4 0.19  0.35   1683 #> 5 0.34  0.47   1683 #> 6 0.93  0.25   1683 #> 7 0.12  0.33   1683  pigs3 %>%    debit_map() #> # A tibble: 7 × 11 #>   x     sd        n consistency rounding   sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>         <dbl> <lgl>            <dbl> #> 1 0.53  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 2 0.44  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 3 0.77  0.42   1683 TRUE        up_or_down    0.415 TRUE             0.425 #> 4 0.19  0.35   1683 FALSE       up_or_down    0.345 TRUE             0.355 #> 5 0.34  0.47   1683 TRUE        up_or_down    0.465 TRUE             0.475 #> 6 0.93  0.25   1683 TRUE        up_or_down    0.245 TRUE             0.255 #> 7 0.12  0.33   1683 TRUE        up_or_down    0.325 TRUE             0.335 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl>  pigs3 %>%    debit_map() %>%    debit_plot()"},{"path":"https://lhdjung.github.io/scrutiny/index.html","id":"guiding-ideas","dir":"","previous_headings":"","what":"Guiding ideas","title":"Error detection in science","text":"(…) critical inspection published literature mischaracterized hobby overly cynical, -called “methodological terrorism”. contrary, carefully evaluating presented data cornerstone scientific investigation, logical apply also published literature. willing critically assess published studies, also guarantee veracity. — van der Zee et al. (2017, pp. 8-9) (…) data thugs (…) demand data receive , contact editors universities threaten write blogs tweets errors uncovered. — Eric . Stewart (six retractions; quoted Pickett 2020, p. 178)","code":""},{"path":"https://lhdjung.github.io/scrutiny/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Error detection in science","text":"Pickett, Justin T. „Stewart Retractions: Quantitative Qualitative Analysis\". Econ Journal Watch 17, Nr. 1 (March 2020): 152–90. URL: https://econjwatch.org/articles/-stewart-retractions--quantitative--qualitative-analysis. van der Zee, Tim, Jordan Anaya, und Nicholas J. L. Brown. „Statistical Heartburn: Attempt Digest Four Pizza Publications Cornell Food Brand Lab\". BMC Nutrition 3, Nr. 1 (Dezember 2017): 54. https://doi.org/10.1186/s40795-017-0167-x.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/audit.html","id":null,"dir":"Reference","previous_headings":"","what":"Summaries of scrutiny objects — audit","title":"Summaries of scrutiny objects — audit","text":"audit() S3 generic follow scrutiny functions run tests data frame. summarizes results tests presents summaries tibble. list functions return objects classes audit() methods. means can run audit() output returned functions. Go documentation particular function named learn audit() method.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/audit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summaries of scrutiny objects — audit","text":"","code":"audit(data)"},{"path":"https://lhdjung.github.io/scrutiny/reference/audit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summaries of scrutiny objects — audit","text":"data data frame one classes named .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/audit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summaries of scrutiny objects — audit","text":"tibble (data frame) test summary statistics.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/audit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summaries of scrutiny objects — audit","text":"","code":"# For GRIM-testing: pigs1 %>%   grim_map() %>%   audit() #> # A tibble: 1 × 7 #>   incons_cases all_cases incons_rate mean_grim_ratio incons_to_ratio #>          <dbl>     <dbl>       <dbl>           <dbl>           <dbl> #> 1            8        12       0.667           0.724           0.921 #> # … with 2 more variables: testable_cases <dbl>, testable_rate <dbl>  # For detecting duplicates: pigs4 %>%   duplicate_detect() %>%   audit() #> # A tibble: 3 × 4 #>   variable n_duplicated n_total dup_rate #>   <chr>           <int>   <int>    <dbl> #> 1 snout               3       5      0.6 #> 2 tail                1       5      0.2 #> 3 .total              4      10      0.4"},{"path":"https://lhdjung.github.io/scrutiny/reference/before_parens.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract substrings from before and inside parentheses — before_parens","title":"Extract substrings from before and inside parentheses — before_parens","text":"Two functions extract substrings inside parentheses (brackets, curly braces): before_parens() inside_parens(). See split_by_parens() split columns data frame parts.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/before_parens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract substrings from before and inside parentheses — before_parens","text":"","code":"before_parens(string, sep = \"parens\")  inside_parens(string, sep = \"parens\")"},{"path":"https://lhdjung.github.io/scrutiny/reference/before_parens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract substrings from before and inside parentheses — before_parens","text":"string Vector strings parentheses, brackets, curly braces. sep String. split . Either \"parens\", \"brackets\", \"braces\". Default \"parens\".","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit.html","id":null,"dir":"Reference","previous_headings":"","what":"The DEBIT (descriptive binary) test — debit","title":"The DEBIT (descriptive binary) test — debit","text":"debit() tests summaries binary data consistency: mean standard deviation binary data given, consistent reported sample size? function vectorized, recommended use debit_map() testing multiple cases.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The DEBIT (descriptive binary) test — debit","text":"","code":"debit(   x,   sd,   n,   formula = \"mean_n\",   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )"},{"path":"https://lhdjung.github.io/scrutiny/reference/debit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The DEBIT (descriptive binary) test — debit","text":"x String. Mean binary distribution. sd String. Sample standard deviation binary distribution. n Integer. Total sample size. formula String. Formula used compute SD binary distribution. Currently, default, \"mean_n\", supported. rounding String. Rounding method methods used reconstructing SD values sd compared. Default \"up_or_down\" (5). options, see documentation grim(), section Details. threshold Integer. rounding set \"up_from\", \"down_from\", \"up_from_or_down_from\", set threshold number reconstructed values rounded . Otherwise irrelevant. Default 5. symmetric Boolean. Set symmetric TRUE rounding negative numbers \"\", \"\", \"up_from\", \"down_from\" mirror positive numbers absolute values always equal. Default FALSE.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The DEBIT (descriptive binary) test — debit","text":"Boolean. TRUE x, sd, n mutually consistent, FALSE .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The DEBIT (descriptive binary) test — debit","text":"Heathers, James . J., Nicholas J. L. Brown. 2019. DEBIT: Simple Consistency Test Binary Data. https://osf.io/5vb3u/.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/debit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The DEBIT (descriptive binary) test — debit","text":"","code":"# Check single cases of binary # summary data: debit(x = \"0.36\", sd = \"0.11\", n = 20) #> [1] FALSE"},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply DEBIT to many cases — debit_map","title":"Apply DEBIT to many cases — debit_map","text":"Call debit_map() use DEBIT multiple combinations mean, standard deviation, sample size binary distributions. Mapping function debit(). summary statistics, call audit() results.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply DEBIT to many cases — debit_map","text":"","code":"debit_map(   data,   x = NULL,   sd = NULL,   n = NULL,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE,   show_rec = TRUE,   extra = Inf )"},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply DEBIT to many cases — debit_map","text":"data Data frame. x, sd, n Optionally specify columns data contain means (x), standard deviations (sd), /sample sizes (n). specified , data needs contain columns names. Default NULL. rounding, threshold, symmetric Arguments passed debit(), defaults. show_rec set FALSE, resulting tibble includes columns x, sd, n, consistency. Default TRUE. extra currently used.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply DEBIT to many cases — debit_map","text":"tibble (least) columns -- x, sd, n: inputs. consistency: DEBIT consistency x, sd, n. default, tibble also includes rounding method, boundary values, Boolean information boundary values inclusive . tibble scr_debit_map class, recognized audit() generic.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_map.html","id":"summaries-with-audit-","dir":"Reference","previous_headings":"","what":"Summaries with audit()","title":"Apply DEBIT to many cases — debit_map","text":"S3 method audit() generic, can call audit() following debit_map(). returns tibble columns --- incons_cases: number DEBIT-inconsistent cases. all_cases: total number cases. incons_rate: rate inconsistent cases. mean_x: mean x (mean) value. mean_sd: mean sd value. distinct_n: number distinct n values.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply DEBIT to many cases — debit_map","text":"","code":"# Call `debit_map()` on binary summary # data such as these: # pigs3  # The `consistency` column shows # whether the values to its left # are DEBIT-consistent: pigs3 %>%   debit_map() #> # A tibble: 7 × 11 #>   x     sd        n consistency rounding   sd_lower sd_incl_lower sd_upper #>   <chr> <chr> <int> <lgl>       <chr>         <dbl> <lgl>            <dbl> #> 1 0.53  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 2 0.44  0.50   1683 TRUE        up_or_down    0.495 TRUE             0.505 #> 3 0.77  0.42   1683 TRUE        up_or_down    0.415 TRUE             0.425 #> 4 0.19  0.35   1683 FALSE       up_or_down    0.345 TRUE             0.355 #> 5 0.34  0.47   1683 TRUE        up_or_down    0.465 TRUE             0.475 #> 6 0.93  0.25   1683 TRUE        up_or_down    0.245 TRUE             0.255 #> 7 0.12  0.33   1683 TRUE        up_or_down    0.325 TRUE             0.335 #> # … with 3 more variables: sd_incl_upper <lgl>, x_lower <dbl>, x_upper <dbl>  # Get test summaries with `audit()`: pigs3 %>%   debit_map() %>%   audit() #> # A tibble: 1 × 6 #>   incons_cases all_cases incons_rate mean_x mean_sd distinct_n #>          <dbl>     <int>       <dbl>  <dbl>   <dbl>      <dbl> #> 1            1         7       0.143  0.474   0.403          1"},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize DEBIT results — debit_plot","title":"Visualize DEBIT results — debit_plot","text":"Plot distribution binary data mutual DEBIT consistency. Call function data frame resulted call debit_map(). Various parameters individual geoms can controlled via arguments.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize DEBIT results — debit_plot","text":"","code":"debit_plot(   data,   show_outer_boxes = TRUE,   show_labels = TRUE,   show_full_scale = TRUE,   show_theme_other = TRUE,   color_cons = \"royalblue1\",   color_incons = \"red\",   line_alpha = 1,   line_color = \"black\",   line_linetype = 1,   line_size = 0.5,   rect_alpha = 1,   tile_alpha = 0.15,   tile_height_offset = 0.025,   tile_width_offset = 0.025,   tile_height_min = 0.0375,   tile_width_min = 0.0385,   label_alpha = 0.5,   label_linetype = 3,   label_size = 3.5,   label_linesize = 0.75,   label_force = 175,   label_force_pull = 0.75,   label_padding = 0.5 )"},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize DEBIT results — debit_plot","text":"data Data frame. Result call debit_map(). show_outer_boxes Boolean. outer tiles surround actual data points, making easier spot assess overlap? Default TRUE. show_labels Boolean. data points labels (form \"mean; SD\")? Default TRUE. show_full_scale Boolean. plot fixed full scale, showing entire consistency line independently data? Default TRUE. show_theme_other Boolean. theme modified way fitting plot structure? Default TRUE. color_cons, color_incons Strings. Colors geoms representing consistent inconsistent values, respectively. line_alpha, line_color, line_linetype, line_size Parameters curved DEBIT line. rect_alpha Parameter DEBIT rectangles. (Due nature data mapping, can leeway regarding shape size particular geom.) tile_alpha, tile_height_offset, tile_width_offset, tile_height_min, tile_width_min Parameters outer tiles surrounding DEBIT rectangles. Offset refers distance rectangles within. label_alpha, label_linetype, label_size, label_linesize, label_force, label_force_pull, label_padding Parameters labels showing mean SD values. Passed ggrepel::geom_text_repel(); see information.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize DEBIT results — debit_plot","text":"ggplot object.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/debit_plot.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize DEBIT results — debit_plot","text":"labels created via ggrepel::geom_text_repel(), algorithm designed minimize overlap tiles labels. Yet, take DEBIT line account, locations ultimately random. might therefore resize plot run function times labels localized satisfactory way. alternative present function S3 method ggplot2::autoplot(). However, standalone function allows customizing geom parameters might perhaps provide better accessibility overall.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":null,"dir":"Reference","previous_headings":"","what":"Count decimal places — decimal_places","title":"Count decimal places — decimal_places","text":"decimal_places() counts decimal places numeric vector, string vector can coerced numeric. decimal_places_scalar() much faster takes single input. recommended helper within single-case functions.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count decimal places — decimal_places","text":"","code":"decimal_places(x, sep = \"\\\\.\")  decimal_places_scalar(x, sep = \"\\\\.\")"},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count decimal places — decimal_places","text":"x Numeric (string can coerced numeric). Object decimal places count. sep Substring separates mantissa integer part. Default \"\\\\.\", renders decimal point.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count decimal places — decimal_places","text":"Integer. Number decimal places x.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count decimal places — decimal_places","text":"Decimal places numeric values counted accurately number 15 characters total, including integer part decimal point. possible solutions enter number string count digits. (Converting string sufficient -- numbers need entered quotes.) function ignores whitespace end string, mistake spaces decimal places.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":"trailing-zeros","dir":"Reference","previous_headings":"","what":"Trailing zeros","title":"Count decimal places — decimal_places","text":"trailing zeros matter, convert numeric values strings: numeric values, trailing zeros already dropped, information lost (e.g., 3.70 returns 3.7). Enter values strings instead, \"3.70\" instead 3.70. However, can restore lost trailing zeros restore_zeros() original number decimal places known. need enter many values strings, consider using tibble::tribble() drawing quotation marks around values tribble() column via RStudio's multiple cursors.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/decimal_places.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count decimal places — decimal_places","text":"","code":"# The function works on both numeric values # and strings... decimal_places(x = 2.851) #> [1] 3 decimal_places(x = \"2.851\") #> [1] 3  # ... but trailing zeros are only counted within # strings: decimal_places(x = c(7.3900, \"7.3900\")) #> [1] 2 4  # This doesn't apply to non-trailing zeros; these # behave just like any other digit would: decimal_places(x = c(4.08, \"4.08\")) #> [1] 2 2  # Whitespace at the end of a string is not counted: decimal_places(x = \"6.0     \") #> [1] 1  # This function is much faster, but only # works with a single number or string: decimal_places_scalar(x = 8.13) #> [1] 2 decimal_places_scalar(x = \"5.024\") #> [1] 3"},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count duplicate values — duplicate_count","title":"Count duplicate values — duplicate_count","text":"duplicate_count() returns frequency table. searching data frame, includes values columns frequency count. function blunt tool designed initial data checking. put much weight results. summary statistics, call audit() results.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count duplicate values — duplicate_count","text":"","code":"duplicate_count(x, numeric_only = TRUE)"},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count duplicate values — duplicate_count","text":"x Vector data frame. numeric_only Boolean. TRUE (default), x data frame, function includes numeric columns string columns coercible numeric. Note: careful setting FALSE. can lead kinds coercion issues.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count duplicate values — duplicate_count","text":"tibble two columns — value includes values x. count frequency value x, descending order. tibble scr_dup_count class, recognized audit() generic.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Count duplicate values — duplicate_count","text":"duplicate_count() thin wrapper around janitor::get_dupes(). Use get_dupes() search duplicate rows. function informative values characters.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":"summaries-with-audit-","dir":"Reference","previous_headings":"","what":"Summaries with audit()","title":"Count duplicate values — duplicate_count","text":"S3 method audit() generic, can call audit() following duplicate_count() get summary statistics. mostly self-explaining, count_max count_min directly apply count display respective value numbers, minimal maximal value numbers.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_count.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count duplicate values — duplicate_count","text":"","code":"# Count duplicate values... BJsales %>%   duplicate_count() #> # A tibble: 22 × 2 #>    value count #>    <dbl> <int> #>  1  209.     4 #>  2  219.     3 #>  3  257.     3 #>  4  258.     3 #>  5  202.     2 #>  6  210.     2 #>  7  211.     2 #>  8  212.     2 #>  9  215.     2 #> 10  216.     2 #> # … with 12 more rows  # ...and compute summaries: BJsales %>%   duplicate_count() %>%   audit() #> # A tibble: 2 × 7 #>   term  count_max count_min     n   mean     sd median #>   <chr>     <dbl>     <dbl> <int>  <dbl>  <dbl>  <dbl> #> 1 value      209.      260.    22 232.   21.3     221. #> 2 count        4         2     22   2.23  0.528     2"},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect duplicate values — duplicate_detect","title":"Detect duplicate values — duplicate_detect","text":"every value vector data frame, duplicate_detect() tests whether least one identical value. Test results presented next every value. default, numeric columns string columns coercible numeric tested (x data frame). columns silently dropped. function blunt tool designed initial data checking. put much weight results. summary statistics, call audit() results.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect duplicate values — duplicate_detect","text":"","code":"duplicate_detect(x, numeric_only = TRUE, colname_end = \"dup\")"},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect duplicate values — duplicate_detect","text":"x Vector data frame. numeric_only Boolean. TRUE (default) x data frame, function test numeric columns string columns coercible numeric. Note: careful setting FALSE. can lead kinds coercion issues. colname_end String. Name ending Boolean test result columns. Default \"dup\".","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect duplicate values — duplicate_detect","text":"tibble --- x vector, two columns: input value Boolean has_duplicates. x data frame, output tibble () columns x, columns' right, corresponding Boolean column index value. tibble scr_dup_detect class, recognized audit() generic.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect duplicate values — duplicate_detect","text":"function informative many input values characters . Many may duplicates just chance. example, R's built-iris data set, 99% values duplicates. general, fewer values characters per value , significant duplicate_detect()'s results .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":"summaries-with-audit-","dir":"Reference","previous_headings":"","what":"Summaries with audit()","title":"Detect duplicate values — duplicate_detect","text":"S3 method audit() generic, can call audit() following duplicate_detect(). returns tibble columns --- variable: original data frame's variables least one \"duplicated\" value: one least one duplicate anywhere else data frame. vector, x. n_duplicated: Number \"duplicated\" values variable: least one duplicate anywhere data frame. dup_rate: Rate \"duplicated\" values variable. final row, .total, summarizes across rows: adds n_duplicated n_total columns, calculates average dup_rate column.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/duplicate_detect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect duplicate values — duplicate_detect","text":"","code":"# Find duplicate values in a data frame... duplicate_detect(x = pigs4) #> # A tibble: 5 × 4 #>   snout snout_dup  tail tail_dup #>   <dbl> <lgl>     <dbl> <lgl>    #> 1  4.74 FALSE      6.89 FALSE    #> 2  8.13 TRUE       7.33 FALSE    #> 3  4.22 TRUE       6.10 FALSE    #> 4  4.22 TRUE       7.57 FALSE    #> 5  5.18 FALSE      8.13 TRUE      # ...or in a single vector: duplicate_detect(x = pigs4$snout) #> # A tibble: 5 × 2 #>   value has_duplicates #>   <dbl> <lgl>          #> 1  4.74 FALSE          #> 2  8.13 FALSE          #> 3  4.22 TRUE           #> 4  4.22 TRUE           #> 5  5.18 FALSE           # Summary statistics with `audit()`: pigs4 %>%   duplicate_detect() %>%   audit() #> # A tibble: 3 × 4 #>   variable n_duplicated n_total dup_rate #>   <chr>           <int>   <int>    <dbl> #> 1 snout               3       5      0.6 #> 2 tail                1       5      0.2 #> 3 .total              4      10      0.4  # If there are many values and/or few # characters per value, `duplicate_detect()` # can be misleading: iris %>%   duplicate_detect() #> # A tibble: 150 × 8 #>    Sepal.Length Sepal.Length_dup Sepal.Width Sepal.Width_dup Petal.Length #>           <dbl> <lgl>                  <dbl> <lgl>                  <dbl> #>  1          5.1 TRUE                     3.5 TRUE                     1.4 #>  2          4.9 TRUE                     3   TRUE                     1.4 #>  3          4.7 TRUE                     3.2 TRUE                     1.3 #>  4          4.6 TRUE                     3.1 TRUE                     1.5 #>  5          5   TRUE                     3.6 TRUE                     1.4 #>  6          5.4 TRUE                     3.9 TRUE                     1.7 #>  7          4.6 TRUE                     3.4 TRUE                     1.4 #>  8          5   TRUE                     3.4 TRUE                     1.5 #>  9          4.4 TRUE                     2.9 TRUE                     1.4 #> 10          4.9 TRUE                     3.1 TRUE                     1.5 #> # … with 140 more rows, and 3 more variables: Petal.Length_dup <lgl>, #> #   Petal.Width <dbl>, Petal.Width_dup <lgl>  iris %>%   duplicate_detect() %>%   audit() #> # A tibble: 5 × 4 #>   variable     n_duplicated n_total dup_rate #>   <chr>               <int>   <int>    <dbl> #> 1 Petal.Length          150     150    1     #> 2 Petal.Width           148     150    0.987 #> 3 Sepal.Length          144     150    0.96  #> 4 Sepal.Width           150     150    1     #> 5 .total                592     600    0.987"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":null,"dir":"Reference","previous_headings":"","what":"The GRIM test (granularity-related inconsistency of means) — grim","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"grim() checks reported mean value integer data mathematically consistent reported sample size number items compose mean value. Set percent TRUE x percentage. convert x decimal number adjust decimal count accordingly. function vectorized, recommended use grim_map() testing multiple cases.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"","code":"grim(   x,   n,   items = 1,   percent = FALSE,   show_rec = FALSE,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE,   tolerance = .Machine$double.eps^0.5 )"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"x String. reported mean percentage value. n Integer. reported sample size. items Numeric. number items composing x. Default 1, common case. percent Boolean. Set percent TRUE x percentage. convert decimal number adjust decimal count (.e., increase 2). Default FALSE. show_rec Boolean. set TRUE, output matrix also contains intermediary values GRIM-testing. recommended; instead, use show_rec grim_map(). Default FALSE. rounding String. Rounding method methods used reconstructing values x compared. Default \"up_or_down\" (5). options, see Details. threshold Numeric. rounding set \"up_from\", \"down_from\", \"up_from_or_down_from\", set threshold number reconstructed values rounded . Otherwise, argument plays role. Default 5. symmetric Boolean. Set symmetric TRUE rounding negative numbers \"\", \"\", \"up_from\", \"down_from\" mirror positive numbers absolute values always equal. Default FALSE. tolerance Numeric. Tolerance comparison x possible mean percentage values. Default circa 0.000000015 (1.490116e-08), dplyr::near().","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"Boolean. TRUE x, n, items mutually consistent, FALSE .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"x values need strings strings retain trailing zeros, important GRIM test decimal digits. Use restore_zeros() numeric values (values numeric values point) easily supply trailing zeros might . See documentation . Browse source code grim.R file. grim() vectorized version internal grim_scalar() function found .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"rounding","dir":"Reference","previous_headings":"","what":"Rounding","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"options rounding argument. Reconstructed mean percentage values can rounded either ways: Rounded \"even\" using base R's round(). Rounded \"\" \"\" 5. (Note SAS, SPSS, Stata, Matlab, Excel round \"\" 5, whereas Python rounds \"\" 5.) Rounded \"up_from\" \"down_from\" number, needs specified via threshold argument. Given \"ceiling\" \"floor\" respective decimal place. Rounded towards zero \"trunc\" away zero \"anti_trunc\". default, \"up_or_down\", allows numbers rounded either \"\" \"\" 5 GRIM-testing; likewise \"up_from_or_down_from\" \"ceiling_or_floor\". rounding = \"up_or_down\", n 40 80 x two decimal places, values test inconsistent; note many either rounding = \"\" rounding = \"\", indeed rounding method. part general pattern: n 400 800 x three decimal places, etc. information methods, see documentation round(), round_up(), round_ceiling(). include ways rounding. reconstructed values rounded can also calibrated threshold symmetric arguments.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"Brown, Nicholas J. L., James . J. Heathers. 2017. GRIM Test: Simple Technique Detects Numerous Anomalies Reporting Results Psychology. Social Psychological Personality Science 8 (4): 363–69. https://doi.org/10.1177/1948550616673876.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/grim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The GRIM test (granularity-related inconsistency of means) — grim","text":"","code":"# A mean of 5.19 is not consistent with a sample size of 28: grim(x = \"5.19\", n = 28)    # `x` in quotes! #>  5.19  #> FALSE   # However, it is consistent with a sample size of 32: grim(x = \"5.19\", n = 32) #> 5.19  #> TRUE   # For a scale composed of two items: grim(x = \"2.84\", n = 16, items = 2) #> 2.84  #> TRUE   # With percentages instead of means -- here, 71%: grim(x = \"71\", n = 43, percent = TRUE) #>    71  #> FALSE"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_granularity.html","id":null,"dir":"Reference","previous_headings":"","what":"Granularity of non-continuous scales — grim_granularity","title":"Granularity of non-continuous scales — grim_granularity","text":"grim_granularity() computes minimal difference two means proportions ordinal interval data. grim_items() reverse: converts granularity values number scale items, might used consistency testing functions grim().","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_granularity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Granularity of non-continuous scales — grim_granularity","text":"","code":"grim_granularity(n, items = 1)  grim_items(n, gran, tolerance = .Machine$double.eps^0.5)"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_granularity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Granularity of non-continuous scales — grim_granularity","text":"n Numeric. Sample size. items Numeric. Number items composing scale. Default 1, hold non-Likert scales. gran Numeric. Granularity. tolerance Numeric. grim_items(), tolerance maximal amount results may differ whole numbers. exceed amount, warning shown.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_granularity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Granularity of non-continuous scales — grim_granularity","text":"two functions differ names arguments --- underlying formula (simple). However, clarity, presented distinct. output grim_items() whole numbers, scale items granularity 1. differ next whole number numeric tolerance (determined argument name), warning shown. wrong determine scale's granularity minimal distance two values given distribution. signify values actually differ, can differ priori based scale design. Also, keep mind continuous scales granularity .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_granularity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Granularity of non-continuous scales — grim_granularity","text":"","code":"# If a non-Likert scale ranges from 0 to 3 # and measures 16 cases: grim_granularity(n = 16)   # `items = 1` by default #> [1] 0.0625  # Same but Likert scale with 2 items: grim_granularity(n = 16, items = 2) #> [1] 0.03125  # If a scale is applied to a single case # and has a granularity of 0.5: grim_items(n = 1, gran = 0.5) #> [1] 2  # With more cases, a warning appears # because items can only be whole numbers: grim_items(n = c(10, 15, 20), gran = 0.5) #> Warning: 3 item counts aren't whole numbers #> → This concerns 0.2, 0.1333333, and 0.1. #> ! Item counts have a granularity of 1, so they should be whole numbers. Are you #>   sure about the `n` and `gran` values? #> [1] 0.2000000 0.1333333 0.1000000"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":null,"dir":"Reference","previous_headings":"","what":"GRIM-test many cases at once — grim_map","title":"GRIM-test many cases at once — grim_map","text":"Call grim_map() GRIM-test number combinations mean/proportion, sample size, number items. Mapping function GRIM-testing. Set percent TRUE x values percentages. convert x values decimals adjust decimal count accordingly. Display intermediary numbers GRIM-testing columns setting show_rec TRUE. summary statistics, call audit() results.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GRIM-test many cases at once — grim_map","text":"","code":"grim_map(   data,   items = 1,   percent = FALSE,   x = NULL,   n = NULL,   show_rec = FALSE,   show_prob = FALSE,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE,   tolerance = .Machine$double.eps^0.5,   testables_only = FALSE,   extra = Inf )"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GRIM-test many cases at once — grim_map","text":"data Data frame columns x, n, optionally items (see documentation grim(). default, columns data returned alongside GRIM test results (see extra ). items Integer. items column data, specifies number items composing x values. Default 1, common case. percent Boolean. Set percent TRUE x values percentages. convert decimal numbers adjust decimal count (.e., increase 2). also affects ratio column. Default FALSE. x, n Optionally specify columns data contain means (x) /sample sizes (n). specified , data needs contain columns names. Default NULL. show_rec Boolean. set TRUE, reconstructed numbers GRIM-testing shown columns. See section Reconstructed numbers . Default FALSE. show_prob Boolean. set TRUE, adds prob column contains probability GRIM inconsistency. simply ratio column censored range 0 1. Default FALSE. rounding, threshold, symmetric, tolerance parameters GRIM-testing; see documentation grim(). testables_only Boolean. testables_only set TRUE, GRIM-testable cases (.e., positive GRIM ratio) included. Default FALSE. extra String integer. column(s) data returned output tibble alongside test results, referenced name(s) number(s). Default Inf, returns columns. return none , set extra 0.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GRIM-test many cases at once — grim_map","text":"tibble columns -- x, n, items: inputs. consistency: GRIM consistency x, n, items. <extra>: columns data x, n, items. ratio: GRIM ratio; see grim_ratio(). tibble scr_grim_map class, recognized audit()generic.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":"reconstructed-numbers","dir":"Reference","previous_headings":"","what":"Reconstructed numbers","title":"GRIM-test many cases at once — grim_map","text":"show_rec set TRUE, output includes following additional columns: rec_sum: sum total mean proportion ostensibly derived. rec_x_upper: upper reconstructed x value. rec_x_lower: lower reconstructed x value. rec_x_upper_rounded: rounded rec_x_upper value. rec_x_lower_rounded: rounded rec_x_lower value. default rounding, \"up_or_down\", last two columns replaced two columns specify rounding procedures (.e., \"_up\" \"_down\").","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":"summaries-with-audit-","dir":"Reference","previous_headings":"","what":"Summaries with audit()","title":"GRIM-test many cases at once — grim_map","text":"S3 method audit(), can call audit() following grim_map() get summary grim_map()'s results. tibble single row columns -- incons_cases: number GRIM-inconsistent value sets. all_cases: total number value sets. incons_rate: proportion GRIM-inconsistent value sets. mean_grim_ratio: average GRIM ratios. incons_to_ratio: ratio incons_rate mean_grim_ratio. testable_cases: number GRIM-testable value sets (.e., positive ratio). testable_rate: proportion GRIM-testable value sets.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GRIM-test many cases at once — grim_map","text":"","code":"# Use `grim_map()` on data like these: pigs1 #> # A tibble: 12 × 2 #>    x         n #>    <chr> <dbl> #>  1 7.22     32 #>  2 4.74     25 #>  3 5.23     29 #>  4 2.57     24 #>  5 6.77     27 #>  6 2.68     28 #>  7 7.01     29 #>  8 7.38     26 #>  9 3.14     27 #> 10 6.89     31 #> 11 5.00     25 #> 12 0.24     28  # The `consistency` column shows # whether the values to its left # are GRIM-consistent: pigs1 %>%   grim_map() #> # A tibble: 12 × 5 #>    x         n items consistency ratio #>    <chr> <int> <int> <lgl>       <dbl> #>  1 7.22     32     1 TRUE         0.68 #>  2 4.74     25     1 FALSE        0.75 #>  3 5.23     29     1 FALSE        0.71 #>  4 2.57     24     1 FALSE        0.76 #>  5 6.77     27     1 FALSE        0.73 #>  6 2.68     28     1 TRUE         0.72 #>  7 7.01     29     1 FALSE        0.71 #>  8 7.38     26     1 TRUE         0.74 #>  9 3.14     27     1 FALSE        0.73 #> 10 6.89     31     1 FALSE        0.69 #> 11 5.00     25     1 TRUE         0.75 #> 12 0.24     28     1 FALSE        0.72  # Display intermediary numbers from # GRIM-testing with `show_rec = TRUE`: pigs1 %>%   grim_map(show_rec = TRUE) #> # A tibble: 12 × 12 #>    x         n items consistency rec_sum rec_x_upper rec_x_lower #>    <chr> <int> <int> <lgl>         <dbl>       <dbl>       <dbl> #>  1 7.22     32     1 TRUE         231.          7.25       7.22  #>  2 4.74     25     1 FALSE        118.          4.76       4.72  #>  3 5.23     29     1 FALSE        152.          5.24       5.21  #>  4 2.57     24     1 FALSE         61.7         2.58       2.54  #>  5 6.77     27     1 FALSE        183.          6.78       6.74  #>  6 2.68     28     1 TRUE          75.0         2.71       2.68  #>  7 7.01     29     1 FALSE        203.          7.03       7     #>  8 7.38     26     1 TRUE         192.          7.38       7.35  #>  9 3.14     27     1 FALSE         84.8         3.15       3.11  #> 10 6.89     31     1 FALSE        214.          6.90       6.87  #> 11 5.00     25     1 TRUE         125           5          5     #> 12 0.24     28     1 FALSE          6.72        0.25       0.214 #> # … with 5 more variables: rec_x_upper_rounded_up <dbl>, #> #   rec_x_upper_rounded_down <dbl>, rec_x_lower_rounded_up <dbl>, #> #   rec_x_lower_rounded_down <dbl>, ratio <dbl>  # Get summaries with `audit()`: pigs1 %>%   grim_map() %>%   audit() #> # A tibble: 1 × 7 #>   incons_cases all_cases incons_rate mean_grim_ratio incons_to_ratio #>          <dbl>     <dbl>       <dbl>           <dbl>           <dbl> #> 1            8        12       0.667           0.724           0.921 #> # … with 2 more variables: testable_cases <dbl>, testable_rate <dbl>"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize GRIM test results — grim_plot","title":"Visualize GRIM test results — grim_plot","text":"grim_plot() visualizes summary data mutual GRIM consistency. Call function data frame resulted call grim_map(). Consistent inconsistent value pairs input data frame shown distinctive colors. default, consistent value pairs blue inconsistent ones red. parameters underlying geoms can controlled via arguments. background raster follows rounding argument grim_map() call (unless plotted mean proportion values 2 decimal places, case gradient shown, raster).","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize GRIM test results — grim_plot","text":"","code":"grim_plot(   data = NULL,   show_data = TRUE,   show_raster = TRUE,   show_gradient = TRUE,   n = NULL,   digits = NULL,   rounding = \"up_or_down\",   color_cons = \"royalblue1\",   color_incons = \"red\",   tile_alpha = 1,   tile_size = 1.5,   raster_alpha = 1,   raster_color = \"grey75\" )"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize GRIM test results — grim_plot","text":"data Data frame. Result call grim_map(). show_data Boolean. set FALSE, test results data displayed. Choose want show background raster. can control plot parameters directly via n, digits, rounding arguments. Default TRUE. show_raster Boolean. TRUE (default), plot background raster. show_gradient Boolean. number decimal places 3 greater, gradient shown signal overall probability GRIM inconsistency? Default TRUE. n Integer. Maximal value x-axis. Default NULL, case n becomes 10 ^ digits (e.g., 100 digits 2). digits Integer. relevant show_data set FALSE. plot constructed data x values many decimal places. Default 2. rounding String. relevant show_data set FALSE. plot constructed data rounded particular way. Default \"up_or_down\". color_cons, color_incons Strings. Fill colors consistent inconsistent scatter points. Defaults \"royalblue1\" (consistent) \"red\" (inconsistent). tile_alpha, tile_size Numeric. parameters scatter points: opacity , indirectly, size. Defaults 1 1.5. raster_alpha, raster_color Numeric string, respectively. Parameters background raster: opacity fill color. Defaults 1 \"grey75\".","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_plot.html","id":"background-raster","dir":"Reference","previous_headings":"","what":"Background raster","title":"Visualize GRIM test results — grim_plot","text":"background raster shows probability GRIM-inconsistency random means proportions, 0 (inconsistent) greatest number x-axis (consistent). number decimal places inputs -- means percentages -- 3 greater, individual points small display. cases, raster gradient, showing overall trend. raster makes sense respect one specific number decimal places, function throw error numbers differ among input x values (show_raster TRUE). can avoid error force plotting specifying digits number decimal places raster gradient displayed. 1 2 decimal places, raster specific rounding procedure. raster varies rounding procedure, automatically correspond rounding argument specified preceding grim_map() call. works fast raster based data saved package , data need generated anew every time function called. Inconsistent value sets marked dark boxes. places raster denote consistent value sets. raster independent data -- follows rounding specification grim_map() call digits argument grim_plot(). Display \"empty\" plot, one without empirical test results, setting show_data FALSE. can control key parameters plot digits rounding. grim_map()'s default rounding, \"up_or_down\", strikingly values flagged inconsistent sample sizes 40 80 (4 8). effect disappears rounding set value. list values rounding can take, see documentation grim(), section Rounding. 4/8 leniency effect arises accepting values rounded either careful conservative rounding procedure. case, grim_plot() cause effect --- reveals .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize GRIM test results — grim_plot","text":"","code":"# Call `grim_plot()` following `grim_map()`: pigs1 %>%   grim_map() %>%   grim_plot()   # If you change the rounding procedure # in `grim_map()`, the plot will # follow automatically: pigs1 %>%   grim_map(rounding = \"up\") %>%   grim_plot()   # For percentages, the y-axis # label also changes automatically: pigs2 %>%   grim_map(percent = TRUE) %>%   grim_plot() #> ℹ `x` converted from percentage"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_total.html","id":null,"dir":"Reference","previous_headings":"","what":"Count possible GRIM inconsistencies — grim_total","title":"Count possible GRIM inconsistencies — grim_total","text":"Count GRIM-inconsistencies possible given mean percentage's number decimal places (D) corresponding sample size. grim_total() returns absolute number. grim_ratio() returns proportion normalized 10^D therefore comparable across mean percentage values reported varying D.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_total.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count possible GRIM inconsistencies — grim_total","text":"","code":"grim_total(x, n, items = 1, percent = FALSE)  grim_ratio(x, n, items = 1, percent = FALSE)"},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_total.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count possible GRIM inconsistencies — grim_total","text":"x String numeric. Mean percentage value computed data integer units (e.g., mean scores Likert scale percentage study participants condition). Note: Numeric inputs include trailing zeros, although important functions. See documentation decimal_places(). n Integer. Sample size corresponding x. items Integer. Number items composing mean percentage value question. Default 1. percent Boolean. Set percent TRUE x expressed proportion 100 rather 1. functions account fact increasing decimal count 2. Default FALSE.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_total.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count possible GRIM inconsistencies — grim_total","text":"Integer numeric. number proportion possible GRIM inconsistencies.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/grim_total.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Count possible GRIM inconsistencies — grim_total","text":"","code":"# Many value sets are inconsistent here: grim_total(x = \"83.29\", n = 21) #> [1] 79 grim_ratio(x = \"83.29\", n = 21) #> [1] 0.79  # No sets are inconsistent in this case... grim_total(x = \"5.14\", n = 83) #> [1] 17 grim_ratio(x = \"5.14\", n = 83) #> [1] 0.17  # ... but most would be if `x` was a percentage: grim_total(x = \"5.14\", n = 83, percent = TRUE) #> [1] 9917 grim_ratio(x = \"5.14\", n = 83, percent = TRUE) #> [1] 0.9917"},{"path":"https://lhdjung.github.io/scrutiny/reference/is_subset_of.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for subsets, supersets, and equal sets — is_subset_of","title":"Test for subsets, supersets, and equal sets — is_subset_of","text":"Functions take vector test whether particular relation another vector. second vector entered either three ways -- Enter directly (basic functions): is_subset_of() tests vector subset another vector; .e., elements contained second one. is_superset_of() reverse: tests first vector contains elements second one. is_equal_set() tests vectors exactly values. Enter values: is_subset_of_vals(), is_superset_of_vals(), is_equal_set_vals() variants take single vector plus number arguments. treated like elements second vector basic functions . Enter multiple vectors jointly contain values: Finally, is_subset_of_vecs(), is_superset_of_vecs(), is_equal_set_vecs() take one vector plus number vectors treat elements (!) like elements second vector basic functions .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/is_subset_of.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for subsets, supersets, and equal sets — is_subset_of","text":"","code":"is_subset_of(x, y)  is_superset_of(x, y)  is_equal_set(x, y)  is_subset_of_vals(x, ...)  is_superset_of_vals(x, ...)  is_equal_set_vals(x, ...)  is_subset_of_vecs(x, ...)  is_superset_of_vecs(x, ...)  is_equal_set_vecs(x, ...)"},{"path":"https://lhdjung.github.io/scrutiny/reference/is_subset_of.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for subsets, supersets, and equal sets — is_subset_of","text":"x vector. y vector. basic functions, _vals _vecs. ... _vals functions, number values x might contain; _vecs functions, number vectors elements x might contain.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/is_subset_of.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for subsets, supersets, and equal sets — is_subset_of","text":"single Boolean value.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/is_subset_of.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test for subsets, supersets, and equal sets — is_subset_of","text":"_vals variants meant flexible, interactive subset/superset testing. , can guess values might collectively fulfill role second vector, can just add call. _vecs variants likewise offer flexibility, also bridge gap vectors values contained . functions simply check values present, regardless often value occurs. words, look types count tokens.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/is_subset_of.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for subsets, supersets, and equal sets — is_subset_of","text":"","code":"# Define example vectors: ab <- c(\"a\", \"b\") abc <- c(\"a\", \"b\", \"c\") abcde <- c(\"a\", \"b\", \"c\", \"d\", \"e\")  # `is_subset_of()` tests if a vector is # completely covered by another one: abc %>% is_subset_of(ab) #> [1] FALSE abc %>% is_subset_of(abc) #> [1] TRUE abc %>% is_subset_of(abcde) #> [1] TRUE  # To the contrary, `is_superset_of()` tests if the # first vector completely covers the second one: abc %>% is_superset_of(ab) #> [1] TRUE abc %>% is_superset_of(abc) #> [1] TRUE abc %>% is_superset_of(abcde) #> [1] FALSE  # `is_equal_set()` tests both of the above -- # i.e., if both vectors have exactly the # same values: abc %>% is_equal_set(ab) #> [1] FALSE abc %>% is_equal_set(abc) #> [1] TRUE abc %>% is_equal_set(abcde) #> [1] FALSE  # Each of the three functions has a `_vals` variant # that doesn't take a second vector like the first # one, but any number of other arguments. These are # jointly treated like the elements of the second # vector in the basic functions: abc %>% is_subset_of_vals(\"a\", \"b\") #> [1] FALSE abc %>% is_subset_of_vals(\"a\", \"b\", \"c\") #> [1] TRUE abc %>% is_subset_of_vals(\"a\", \"b\", \"c\", \"d\", \"e\") #> [1] TRUE  # (... and likewise for supersets and equal sets.)  # The `_vecs` functions are like the basic ones # but for any number of other vectors: abc %>% is_subset_of_vecs(ab, \"c\") #> Error in .f(.x[[i]], ...): object 'ab' not found abc %>% is_subset_of_vecs(ab, c(\"c\", \"d\")) #> Error in .f(.x[[i]], ...): object 'ab' not found abc %>% is_subset_of_vecs(ab, c(3, 4, 5)) #> Error in .f(.x[[i]], ...): object 'ab' not found  # (... again, likewise for supersets and equal sets.)"},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs1.html","id":null,"dir":"Reference","previous_headings":"","what":"Means and sample sizes for GRIM-testing — pigs1","title":"Means and sample sizes for GRIM-testing — pigs1","text":"fictional dataset means sample sizes flying pigs. can used demonstrate functionality grim_map() functions building .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Means and sample sizes for GRIM-testing — pigs1","text":"","code":"pigs1"},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs1.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Means and sample sizes for GRIM-testing — pigs1","text":"tibble (data frame) 12 rows 2 columns. columns : x String. Means. n Numeric. Sample sizes.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs2.html","id":null,"dir":"Reference","previous_headings":"","what":"Percentages and sample sizes for GRIM-testing — pigs2","title":"Percentages and sample sizes for GRIM-testing — pigs2","text":"fictional dataset percentages sample sizes flying pigs. can used demonstrate functionality grim_map(), particularly percent argument, functions building .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Percentages and sample sizes for GRIM-testing — pigs2","text":"","code":"pigs2"},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs2.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Percentages and sample sizes for GRIM-testing — pigs2","text":"tibble (data frame) 6 rows 2 columns. columns : x String. Percentages. n Numeric. Sample sizes.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs3.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary means and standard deviations for using DEBIT — pigs3","title":"Binary means and standard deviations for using DEBIT — pigs3","text":"fictional dataset means standard deviations binary distribution related flying pigs. can used demonstrate functionality debit_map() functions building .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs3.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary means and standard deviations for using DEBIT — pigs3","text":"","code":"pigs3"},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs3.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Binary means and standard deviations for using DEBIT — pigs3","text":"tibble (data frame) 7 rows 3 columns. columns : x String. Means. sd String. Standard deviations. n Numeric. Sample sizes.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs4.html","id":null,"dir":"Reference","previous_headings":"","what":"Data with duplications — pigs4","title":"Data with duplications — pigs4","text":"fictional dataset observations flying pigs. Two pairs values duplicates. dataset can used demonstrate functionality duplicate_detect() functions building .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs4.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data with duplications — pigs4","text":"","code":"pigs4"},{"path":"https://lhdjung.github.io/scrutiny/reference/pigs4.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data with duplications — pigs4","text":"tibble (data frame) 7 rows 3 columns. columns : x String. Means. sd String. Standard deviations. n Numeric. Sample sizes.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"pipe, %>%, imported magrittr reexported scrutiny users. See magrittr::%>% details.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://lhdjung.github.io/scrutiny/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround.html","id":null,"dir":"Reference","previous_headings":"","what":"General interface to reconstructing rounded numbers — reround","title":"General interface to reconstructing rounded numbers — reround","text":"reround() takes one intermediate reconstructed values rounds specific way -- namely, way supposed rounded originally, process generated reported values. function provides interface scrutiny's rounding functions well base::round(). used helper within grim() debit(), might find use places consistency testing reconstruction statistical analyses.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"General interface to reconstructing rounded numbers — reround","text":"","code":"reround(   x,   digits = 0,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )"},{"path":"https://lhdjung.github.io/scrutiny/reference/reround.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"General interface to reconstructing rounded numbers — reround","text":"x Numeric. Vector possibly original values. digits Integer. Number decimal places reported key values (.e., mean percentage within grim(), standard deviation within debit()). rounding String. rounding method supposed used originally. See documentation grim(), section Rounding. Default \"up_or_down\", returns two values: x rounded . threshold Integer. rounding set \"up_from\", \"down_from\", \"up_from_or_down_from\", threshold needs set number reconstructed values rounded . Otherwise irrelevant. Default 5. symmetric Boolean. Set symmetric TRUE rounding negative numbers \"up_or_down\", \"\", \"\", \"up_from_or_down_from\", \"up_from\", \"down_from\" mirror positive numbers absolute values always equal. Otherwise irrelevant. Default FALSE.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"General interface to reconstructing rounded numbers — reround","text":"Numeric vector length 1 2. (length 1 unless roundingis \"up_or_down\", \"up_from_or_down_from\", \"ceiling_or_floor\", case length 2.)","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"General interface to reconstructing rounded numbers — reround","text":"reround() internally calls appropriate rounding function(s) determined rounding argument. See documentation grim(), section Rounding, complete list values rounding can take. nine rounding functions , see documentation round_up(), round_ceiling(), base::round().","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround_to_fraction.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized rounding to the nearest fraction of a specified denominator — reround_to_fraction","title":"Generalized rounding to the nearest fraction of a specified denominator — reround_to_fraction","text":"Two functions round numbers specific fractions, just next higher decimal level. inspired janitor::round_to_fraction() feature options reround(): reround_to_fraction() closely follows janitor::round_to_fraction() first rounding fractions whole number, optionally rounding result specific number digits usual way. reround_to_fraction_level() rounds nearest fraction number specific decimal level (.e., number digits), without subsequent rounding. closer conventional rounding functions.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround_to_fraction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized rounding to the nearest fraction of a specified denominator — reround_to_fraction","text":"","code":"reround_to_fraction(   x = NULL,   denominator = 1,   digits = Inf,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )  reround_to_fraction_level(   x = NULL,   denominator = 1,   digits = 0,   rounding = \"up_or_down\",   threshold = 5,   symmetric = FALSE )"},{"path":"https://lhdjung.github.io/scrutiny/reference/reround_to_fraction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized rounding to the nearest fraction of a specified denominator — reround_to_fraction","text":"x Numeric. Vector numbers rounded. denominator Numeric (>= 1) . x rounded nearest fraction denominator. Default 1. digits Numeric (whole numbers). reround_to_fraction(): digits specified, values resulting fractional rounding subsequently rounded many decimal places. set \"auto\", internally becomes ceiling(log10(denominator)) + 1, janitor::round_to_fraction(). Default Inf, case subsequent rounding. reround_to_fraction_level(): function round fraction number decimal level specified digits. Default 0. rounding, threshold, symmetric arguments passed reround().","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/reround_to_fraction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized rounding to the nearest fraction of a specified denominator — reround_to_fraction","text":"Numeric vector length x unless rounding either \"up_or_down\", \"up_from_or_down_from\", \"ceiling_or_floor\". cases, always length 2.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/reround_to_fraction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized rounding to the nearest fraction of a specified denominator — reround_to_fraction","text":"","code":"#`reround_to_fraction()` rounds `0.4` # to `0` if `denominator` is `1`, which # is the usual integer rounding... reround_to_fraction(0.4, denominator = 1, rounding = \"even\") #> [1] 0  # ...but if `denominator` is `2`, it rounds to the nearest # fraction of 2, which is `0.5`: reround_to_fraction(0.4, denominator = 2, rounding = \"even\") #> [1] 0.5  # Likewise with fractions of 3: reround_to_fraction(0.25, denominator = 3, rounding = \"even\") #> [1] 0.3333333  # The default for `rounding` is to round # both up and down, as in `reround()`: reround_to_fraction(0.4, denominator = 2) #> [1] 0.5 0.5  # These two rounding procedures differ # at the tie points: reround_to_fraction(0.25, denominator = 2) #> [1] 0.5 0.0  # `reround_to_fraction_level()`, in contrast, # uses `digits` to determine some decimal level, # and then rounds to the closest fraction at # that level: reround_to_fraction_level(0.12345, denominator = 2, digits = 0) #> [1] 0 0 reround_to_fraction_level(0.12345, denominator = 2, digits = 1) #> [1] 0.1 0.1 reround_to_fraction_level(0.12345, denominator = 2, digits = 2) #> [1] 0.125 0.125"},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":null,"dir":"Reference","previous_headings":"","what":"Restore trailing zeros — restore_zeros","title":"Restore trailing zeros — restore_zeros","text":"restore_zeros() takes vector values might lost trailing zeros, likely registered numeric. turns value string adds trailing zeros mantissa hits limit. default limit number digits longest mantissa vector's values. length integer part plays role. rely default limit without checking: original width larger longest extant mantissa might lost trailing zeros.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restore trailing zeros — restore_zeros","text":"","code":"restore_zeros(x, width = NULL, sep = \"\\\\.\")"},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restore trailing zeros — restore_zeros","text":"x Numeric (string coercible numeric). Vector numbers might lost trailing zeros. width Integer. Number decimal places mantissas , including restored zeros. Default NULL, case number characters longest mantissa used instead. sep Substring separates mantissa integer part. Default \"\\\\.\", renders decimal point.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restore trailing zeros — restore_zeros","text":"string vector. least strings newly restored zeros, unless input values number decimal places.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restore trailing zeros — restore_zeros","text":"function exploits fact groups summary values means percentages often reported number decimal places. number known values entered strings, trailing zeros lost. case, restore_zeros() helpful prepare data consistency testing functions grim_map() debit_map(). Otherwise, probably used.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":"displaying-decimal-places","dir":"Reference","previous_headings":"","what":"Displaying decimal places","title":"Restore trailing zeros — restore_zeros","text":"might see decimal places numeric values vector, consequently wonder restore_zeros(), applied vector, adds many zeros. displayed numbers, unlike stored numbers, often rounded. vector x, can count characters longest mantissa among values like : x %>% decimal_places() %>% max()","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/restore_zeros.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restore trailing zeros — restore_zeros","text":"","code":"# By default, the target width is that of # the longest mantissa: vec <- c(212, 75.38, 4.9625) vec %>% restore_zeros() #> [1] \"212.0000\" \"75.3800\"  \"4.9625\"    # Alternatively, supply a number via `width`: vec %>% restore_zeros(width = 6) #> [1] \"212.000000\" \"75.380000\"  \"4.962500\""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_ceiling.html","id":null,"dir":"Reference","previous_headings":"","what":"Always round up, down, toward zero, or away from it — round_ceiling","title":"Always round up, down, toward zero, or away from it — round_ceiling","text":"Round decimal number either four ways: round_ceiling() always rounds , round_floor() always rounds , round_trunc() always rounds toward 0, round_anti_trunc() always rounds away 0. rounding methods seem widely used. Still, featured case needed reconstruction.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_ceiling.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Always round up, down, toward zero, or away from it — round_ceiling","text":"","code":"round_ceiling(x, digits = 0)  round_floor(x, digits = 0)  round_trunc(x, digits = 0)  anti_trunc(x)  round_anti_trunc(x, digits = 0)"},{"path":"https://lhdjung.github.io/scrutiny/reference/round_ceiling.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Always round up, down, toward zero, or away from it — round_ceiling","text":"x Numeric. decimal number round. digits Integer. Number digits round x . Default 0.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_ceiling.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Always round up, down, toward zero, or away from it — round_ceiling","text":"Numeric. x rounded digits (except anti_trunc(), digits argument).","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_ceiling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Always round up, down, toward zero, or away from it — round_ceiling","text":"round_ceiling(), round_floor(), round_trunc() generalize base functions ceiling(), floor(), trunc(), include special cases: default value digits, 0, round_* functions equivalent respective base counterparts. last round_* function, round_anti_trunc(), generalizes another function presented : anti_trunc() works like trunc() except moves away 0, rather towards . , whereas trunc() minimizes absolute value x (compared rounding functions), anti_trunc() maximizes . anti_trunc(x) therefore equal trunc(x)  + 1 x positive, trunc(x) - 1 x negative. round_anti_trunc(), , generalizes anti_trunc() just round_ceiling() generalizes ceiling(), etc. Moreover, round_trunc() equivalent round_floor() positive numbers round_ceiling() negative numbers. reverse true round_anti_trunc(): equivalent round_ceiling() positive numbers round_floor() negative numbers.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/round_ceiling.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Always round up, down, toward zero, or away from it — round_ceiling","text":"","code":"# Always round up: round_ceiling(x = 4.52, digits = 1)        # 2 cut off #> [1] 4.6  # Always round down: round_floor(x = 4.67, digits = 1)          # 7 cut off #> [1] 4.6  # Always round toward 0: round_trunc(8.439, digits = 2)             # 9 cut off #> [1] 8.43 round_trunc(-8.439, digits = 2)            # 9 cut off #> [1] -8.43  # Always round away from 0: round_anti_trunc(x = 8.421, digits = 2)    # 1 cut off #> [1] 8.43 round_anti_trunc(x = -8.421, digits = 2)   # 1 cut off #> [1] -8.43"},{"path":"https://lhdjung.github.io/scrutiny/reference/round_up_from.html","id":null,"dir":"Reference","previous_headings":"","what":"Likely rounding procedures — round_up_from","title":"Likely rounding procedures — round_up_from","text":"round_up() rounds 5, round_down() rounds 5. Otherwise, functions work like base::round(). round_up() round_down() special cases round_up_from() round_down_from(), allow users choose custom thresholds rounding , respectively.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_up_from.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likely rounding procedures — round_up_from","text":"","code":"round_up_from(x, digits = 0, threshold, symmetric = FALSE)  round_down_from(x, digits = 0, threshold, symmetric = FALSE)  round_up(x, digits = 0, symmetric = FALSE)  round_down(x, digits = 0, symmetric = FALSE)"},{"path":"https://lhdjung.github.io/scrutiny/reference/round_up_from.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likely rounding procedures — round_up_from","text":"x Numeric. decimal number round. digits Integer. Number digits round x . Default 0. threshold Integer. round_up_from() round_down_from(). Threshold rounding , respectively. Value 5 round_up()'s internal call round_up_from() round_down()'s internal call round_down_from(). symmetric Boolean. Set symmetric TRUE rounding negative numbers mirror positive numbers absolute values equal. Default FALSE.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_up_from.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likely rounding procedures — round_up_from","text":"Numeric. x rounded digits.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/round_up_from.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Likely rounding procedures — round_up_from","text":"functions differ base::round() mainly insofar decision rounding 5 based integer portion x (.e., \"rounding even\"). Instead, round_up_from(), decision determined threshold argument rounding , likewise round_down_from(). threshold constant 5 round_up() round_down(). result, functions predictable less prone floating-point number quirks base::round(). Compare round_down() base::round() data frame rounding 5 created Examples section : round_down() yields continuous sequence final digits 0 9, whereas base::round() behaves way can explained floating point issues. However, surprising behavior part base::round() necessarily flaw (see documentation, vignette: https://rpubs.com/maechler/Rounding). present version R (4.0.0 later), base::round() works fine, functions presented meant replace . main purpose helpers within scrutiny reconstruct computations researchers might used different software. example, SAS, SPSS, Stata, Matlab, Excel round 5, whereas Python rounds 5. use cases might possibly include journal requirements.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/round_up_from.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likely rounding procedures — round_up_from","text":"","code":"# Both `round_up()` and `round_down()` work like # `base::round()` unless the closest digit to be # cut off by rounding is 5:     round_up(x = 9.273, digits = 1)     # 7 cut off #> [1] 9.3  round_down(x = 9.273, digits = 1)     # 7 cut off #> [1] 9.3 base::round(x = 9.273, digits = 1)     # 7 cut off #> [1] 9.3     round_up(x = 7.584, digits = 2)     # 4 cut off #> [1] 7.58  round_down(x = 7.584, digits = 2)     # 4 cut off #> [1] 7.58 base::round(x = 7.584, digits = 2)     # 4 cut off #> [1] 7.58   # Here is the borderline case of 5 rounded by # `round_up()`, `round_down()`, and `base::round()`:  original <- c(     # Define example values     0.05, 0.15, 0.25, 0.35, 0.45,     0.55, 0.65, 0.75, 0.85, 0.95     ) tibble::tibble(        # Output table     original,     round_up = round_up(x = original, digits = 1),     round_down = round_down(x = original, digits = 1),     base_round = base::round(x = original, digits = 1)     ) #> # A tibble: 10 × 4 #>    original round_up round_down base_round #>       <dbl>    <dbl>      <dbl>      <dbl> #>  1     0.05      0.1        0          0   #>  2     0.15      0.2        0.1        0.1 #>  3     0.25      0.3        0.2        0.2 #>  4     0.35      0.4        0.3        0.3 #>  5     0.45      0.5        0.4        0.4 #>  6     0.55      0.6        0.5        0.6 #>  7     0.65      0.7        0.6        0.7 #>  8     0.75      0.8        0.7        0.8 #>  9     0.85      0.9        0.8        0.8 #> 10     0.95      1          0.9        0.9  # (Note: Defining `original` as `seq(0.05:0.95, by = 0.1)` # would lead to wrong results unless `original` is rounded # to 2 or so digits before it's rounded to 1.)"},{"path":"https://lhdjung.github.io/scrutiny/reference/rounding_bias.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute rounding bias — rounding_bias","title":"Compute rounding bias — rounding_bias","text":"Rounding often leads bias, mean rounded distribution different mean original distribution. Call rounding_bias() compute amount bias.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/rounding_bias.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute rounding bias — rounding_bias","text":"","code":"rounding_bias(   x,   digits,   rounding = \"up\",   threshold = 5,   symmetric = FALSE,   mean = TRUE )"},{"path":"https://lhdjung.github.io/scrutiny/reference/rounding_bias.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute rounding bias — rounding_bias","text":"x Numeric string coercible numeric. digits Integer. Number decimal digits x rounded. rounding String. Rounding procedure applied x. See documentation grim(), section Rounding. Default \"\". threshold, symmetric arguments passed reround(). mean Boolean. TRUE (default), mean total bias returned. Set mean FALSE get vector individual biases length x.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/rounding_bias.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute rounding bias — rounding_bias","text":"Numeric. default mean, length 1; otherwise, length x.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/rounding_bias.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute rounding bias — rounding_bias","text":"Bias calculated subtracting original vector, x, vector rounded specified way. function passes arguments except mean reround(). , however, rounding \"\" default, set \"up_or_down\", \"up_from_or_down_from\", \"ceiling_or_floor\".","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/rounding_bias.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute rounding bias — rounding_bias","text":"","code":"# Define example vector: vec <- seq_distance(0.01, string_output = FALSE) vec #>  [1] 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10  # The default rounds `x` up from 5: rounding_bias(x = vec, digits = 1) #> [1] 0.005  # Other rounding procedures are supported, # such as rounding down from 5... rounding_bias(x = vec, digits = 1, rounding = \"down\") #> [1] -0.005  # ...or rounding to even with `base::round()`: rounding_bias(x = vec, digits = 1, rounding = \"even\") #> [1] -0.005"},{"path":"https://lhdjung.github.io/scrutiny/reference/row_to_colnames.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn row values into column names — row_to_colnames","title":"Turn row values into column names — row_to_colnames","text":"Data frames sometimes wrong column names, correct column names stored one rows data frame . remedy issue, call row_to_colnames() data frame: replaces column names values specified rows (default, first one). rows dropped default.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/row_to_colnames.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn row values into column names — row_to_colnames","text":"","code":"row_to_colnames(data, row = 1, collapse = \" \", drop = TRUE)"},{"path":"https://lhdjung.github.io/scrutiny/reference/row_to_colnames.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn row values into column names — row_to_colnames","text":"data Data frame matrix. row Integer. Position rows (one ) jointly contain correct column names. Default 1. collapse String. length row greater 1, new column name many row values pasted together. collapse, , substring two former row values final column names. Default \" \" (space). drop Boolean. TRUE (default), rows specified row removed.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/row_to_colnames.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn row values into column names — row_to_colnames","text":"data frame.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/row_to_colnames.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turn row values into column names — row_to_colnames","text":"multiple rows specified, row values individual column pasted together. special characters might missing. function might useful importing tables PDF, e.g. tabulizer. R, data frames (converted matrices) sometimes issue described .","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/sd_binary_groups.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard deviation of binary data — sd_binary_groups","title":"Standard deviation of binary data — sd_binary_groups","text":"Compute sample SD binary data (.e., 0 1 values) either four ways, based different inputs: sd_binary_groups() takes cell sizes groups, coded 0 coded 1. sd_binary_0_n() takes cell size group coded 0 total sample size. sd_binary_1_n() takes cell size group coded 1 total sample size. sd_binary_mean_n() takes mean total sample size. functions used helpers inside debit(), consequently debit_map().","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/sd_binary_groups.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard deviation of binary data — sd_binary_groups","text":"","code":"sd_binary_groups(group_0, group_1)  sd_binary_0_n(group_0, n)  sd_binary_1_n(group_1, n)  sd_binary_mean_n(mean, n)"},{"path":"https://lhdjung.github.io/scrutiny/reference/sd_binary_groups.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standard deviation of binary data — sd_binary_groups","text":"group_0 Integer. Cell size group coded 0. group_1 Integer. Cell size group coded 1. n Integer. Total sample size. mean Numeric. Mean binary data.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/sd_binary_groups.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standard deviation of binary data — sd_binary_groups","text":"Numeric. Sample standard deviation.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/sd_binary_groups.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Standard deviation of binary data — sd_binary_groups","text":"ADD REFERENCE HEATHERS BROWN (2019 PREPRINT)","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/sd_binary_groups.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Standard deviation of binary data — sd_binary_groups","text":"","code":"# If 127 values are coded as 0 and 153 as 1... sd_binary_groups(group_0 = 127, group_1 = 153) #> [1] 0.4987311  # ...so that n = 280: sd_binary_0_n(group_0 = 127, n = 280) #> [1] 0.4987311 sd_binary_1_n(group_1 = 153, n = 280) #> [1] 0.4987311  # If only the mean and total sample size are # given, or these are more convenient to use, # they still lead to the same result as above # if the mean is given with a sufficiently # large number of decimal places: sd_binary_mean_n(mean = 0.5464286, n = 280) #> [1] 0.4987311"},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_endpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Sequence generation at decimal level — seq_endpoint","title":"Sequence generation at decimal level — seq_endpoint","text":"Functions provide smooth interface generating sequences based input values' decimal depth. function creates sequence step size one unit level input values' ultimate decimal digit (e.g., 2.45, 2.46, 2.47, ...): seq_endpoint() creates sequence one input value another. step size, goes value decimal places. seq_distance() takes starting point , instead endpoint, desired output length. step size, goes starting point. seq_endpoint_df() seq_distance_df() variants create data frame. columns can added tibble::tibble(). Regular arguments respective non-df function, dot .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_endpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sequence generation at decimal level — seq_endpoint","text":"","code":"seq_endpoint(from, to, offset_from = 0, offset_to = 0, string_output = TRUE)  seq_distance(   from,   length_out = 10,   dir = 1,   offset_from = 0,   string_output = TRUE )  seq_endpoint_df(   .from,   .to,   ...,   .offset_from = 0,   .offset_to = 0,   .string_output = TRUE )  seq_distance_df(   .from,   ...,   .length_out = 10,   .dir = 1,   .offset_from = 0,   .offset_to = 0,   .string_output = TRUE )"},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_endpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sequence generation at decimal level — seq_endpoint","text":", .Numeric (string coercible numeric). Starting point sequence. , .Numeric (string coercible numeric). Endpoint sequence. seq_endpoint() seq_endpoint_df(). offset_from, .offset_from Integer. set non-zero number, starting point offset many units level last decimal digit. Default 0. offset_to, .offset_to Integer. set non-zero number, endpoint offset many units level last decimal digit. Default 0. seq_endpoint() seq_endpoint_df(). string_output, .string_output Boolean. TRUE (default), output string vector. Decimal places padded zeros match 's ('s) number decimal places. length_out, .length_out Integer. Length output vector (.e., number values). Default 10. seq_distance() seq_distance_df(). dir, .dir Integer. set -1, sequence goes backward. Default 1. seq_distance() seq_distance_df(). ... columns, added tibble::tibble(). seq_endpoint_df() seq_distance_df().","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_endpoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sequence generation at decimal level — seq_endpoint","text":"String default string_output, numeric otherwise.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_endpoint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sequence generation at decimal level — seq_endpoint","text":"either ends zero, sure enter value string! crucial trailing zeros get dropped numeric values. handy way format numeric values number-strings correctly restore_zeros(). output present functions like default (string_output). seq_endpoint() seq_endpoint_df(), step size determined , whichever decimal places. seq_distance() seq_distance_df(), determined decimal places . functions scrutiny's take base::seq(), wrappers around .","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_endpoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sequence generation at decimal level — seq_endpoint","text":"","code":"# Sequence between two points: seq_endpoint(from = 4.7, to = 5) #> [1] \"4.7\" \"4.8\" \"4.9\" \"5.0\"  # Sequence of some length; default is 10: seq_distance(from = 0.93) #>  [1] \"0.93\" \"0.94\" \"0.95\" \"0.96\" \"0.97\" \"0.98\" \"0.99\" \"1.00\" \"1.01\" \"1.02\" seq_distance(from = 0.93, length_out = 5) #> [1] \"0.93\" \"0.94\" \"0.95\" \"0.96\" \"0.97\"  # Both of these functions can offset the # starting point... seq_endpoint(from = 14.2, to = 15, offset_from = 4) #> [1] \"14.6\" \"14.7\" \"14.8\" \"14.9\" \"15.0\" seq_distance(from = 14.2, offset_from = 4) #>  [1] \"14.6\" \"14.7\" \"14.8\" \"14.9\" \"15.0\" \"15.1\" \"15.2\" \"15.3\" \"15.4\" \"15.5\"  # ...but only `seq_endpoint()` can offset the # endpoint, because of its `to` argument: seq_endpoint(from = 9.5, to = 10, offset_to = 2) #> [1] \"9.5\"  \"9.6\"  \"9.7\"  \"9.8\"  \"9.9\"  \"10.0\" \"10.1\" \"10.2\"  # In return, `seq_distance()` can reverse its direction: seq_distance(from = 20.03, dir = -1) #>  [1] \"20.03\" \"20.02\" \"20.01\" \"20.00\" \"19.99\" \"19.98\" \"19.97\" \"19.96\" \"19.95\" #> [10] \"19.94\"  # Both functions have a `_df` variant that returns # a data frame. Arguments are the same but with a # dot, and further columns can be added as in # `tibble::tibble()`: seq_endpoint_df(.from = 4.7, .to = 5, n = 20) #> # A tibble: 4 × 2 #>   x         n #>   <chr> <dbl> #> 1 4.7      20 #> 2 4.8      20 #> 3 4.9      20 #> 4 5.0      20 seq_distance_df(.from = 0.43, .length_out = 5, sd = 0.08) #> # A tibble: 5 × 2 #>   x        sd #>   <chr> <dbl> #> 1 0.43   0.08 #> 2 0.44   0.08 #> 3 0.45   0.08 #> 4 0.46   0.08 #> 5 0.47   0.08"},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_test_ranking.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank sequence test results — seq_test_ranking","title":"Rank sequence test results — seq_test_ranking","text":"Run function generating sequence seq_endpoint_df() seq_distance_df() testing one scrutiny's mapping functions, grim_map(). rank test's consistent inconsistent results positions sequence.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_test_ranking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank sequence test results — seq_test_ranking","text":"","code":"seq_test_ranking(x, explain = TRUE)"},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_test_ranking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank sequence test results — seq_test_ranking","text":"x Data frame. explain TRUE (default), results come explanation.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/seq_test_ranking.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank sequence test results — seq_test_ranking","text":"function checks provenance test results throws warning correct.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/split_by_parens.html","id":null,"dir":"Reference","previous_headings":"","what":"Split columns by parentheses — split_by_parens","title":"Split columns by parentheses — split_by_parens","text":"Summary statistics often presented like \"2.65 (0.27)\". working tables PDF, can tedious separate values inside parentheses. split_by_parens() automatically. default, operates columns. Output can optionally transformed longer format setting .transform TRUE.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/split_by_parens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split columns by parentheses — split_by_parens","text":"","code":"split_by_parens(   .data,   ...,   .keep = FALSE,   .transform = FALSE,   .sep = \"parens\",   .col1 = \"x\",   .col2 = \"sd\" )"},{"path":"https://lhdjung.github.io/scrutiny/reference/split_by_parens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split columns by parentheses — split_by_parens","text":".data Data frame. split_by_parens(). ... Optionally, name columns .data. Splitting restricted columns. useful values contain parentheses. .keep Boolean. set TRUE, original columns .data also appear output. Default FALSE. .transform Boolean. set TRUE, output transformed better accessible typical follow-tasks. Default FALSE. .sep String. split . Either \"parens\", \"brackets\", \"braces\". Default \"parens\". .col1, .col2 Strings. Endings two column names result splitting column. Default \"x\" .col1 \"sd\" .col2.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/split_by_parens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split columns by parentheses — split_by_parens","text":"tibble string columns.","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/split_by_parens.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split columns by parentheses — split_by_parens","text":"","code":"# Call `split_by_parens()` on data like these: pigs <- tibble::tribble(   ~drone,           ~selfpilot,   \"0.09 (0.21)\",    \"0.19 (0.13)\",   \"0.19 (0.28)\",    \"0.53 (0.10)\",   \"0.62 (0.16)\",    \"0.50 (0.11)\",   \"0.15 (0.35)\",    \"0.57 (0.16)\", )  pigs #> # A tibble: 4 × 2 #>   drone       selfpilot   #>   <chr>       <chr>       #> 1 0.09 (0.21) 0.19 (0.13) #> 2 0.19 (0.28) 0.53 (0.10) #> 3 0.62 (0.16) 0.50 (0.11) #> 4 0.15 (0.35) 0.57 (0.16)  # Basic usage: pigs %>%   split_by_parens() #> # A tibble: 4 × 4 #>   drone_x drone_sd selfpilot_x selfpilot_sd #>   <chr>   <chr>    <chr>       <chr>        #> 1 0.09    0.21     0.19        0.13         #> 2 0.19    0.28     0.53        0.10         #> 3 0.62    0.16     0.50        0.11         #> 4 0.15    0.35     0.57        0.16          # Name specific columns to only return those: pigs %>%   split_by_parens(drone) #> # A tibble: 4 × 2 #>   drone_x drone_sd #>   <chr>   <chr>    #> 1 0.09    0.21     #> 2 0.19    0.28     #> 3 0.62    0.16     #> 4 0.15    0.35      # Pivot the data into a longer format # by setting `.transform` to `TRUE`: pigs %>%   split_by_parens(.transform = TRUE) #> # A tibble: 8 × 3 #>   .origin   x     sd    #>   <chr>     <chr> <chr> #> 1 drone     0.09  0.21  #> 2 drone     0.19  0.28  #> 3 drone     0.62  0.16  #> 4 drone     0.15  0.35  #> 5 selfpilot 0.19  0.13  #> 6 selfpilot 0.53  0.10  #> 7 selfpilot 0.50  0.11  #> 8 selfpilot 0.57  0.16   # Choose different column names or # name suffixes with `.col1` and `.col2`: pigs %>%   split_by_parens(.col1 = \"beta\", .col2 = \"se\") #> # A tibble: 4 × 4 #>   drone_beta drone_se selfpilot_beta selfpilot_se #>   <chr>      <chr>    <chr>          <chr>        #> 1 0.09       0.21     0.19           0.13         #> 2 0.19       0.28     0.53           0.10         #> 3 0.62       0.16     0.50           0.11         #> 4 0.15       0.35     0.57           0.16          pigs %>%   split_by_parens(.transform = TRUE,   .col1 = \"beta\", .col2 = \"se\") #> # A tibble: 8 × 3 #>   .origin   beta  se    #>   <chr>     <chr> <chr> #> 1 drone     0.09  0.21  #> 2 drone     0.19  0.28  #> 3 drone     0.62  0.16  #> 4 drone     0.15  0.35  #> 5 selfpilot 0.19  0.13  #> 6 selfpilot 0.53  0.10  #> 7 selfpilot 0.50  0.11  #> 8 selfpilot 0.57  0.16"},{"path":"https://lhdjung.github.io/scrutiny/reference/tidyeval.html","id":null,"dir":"Reference","previous_headings":"","what":"Tidy eval helpers — tidyeval","title":"Tidy eval helpers — tidyeval","text":"page lists tidy eval tools reexported scrutiny rlang. learn using tidy eval scripts packages high level, see dplyr programming vignette ggplot2 packages vignette. Metaprogramming section Advanced R may also useful deeper dive. tidy eval operators {{, !!, !!! syntactic constructs specially interpreted tidy eval functions. mostly need {{, !! !!! advanced operators use simple cases. curly-curly operator {{ allows tunnel data-variables passed function arguments inside tidy eval functions. {{ designed individual arguments. pass multiple arguments contained dots, use ... normal way. enquo() enquos() delay execution one several function arguments. former returns single expression, latter returns list expressions. defused, expressions longer evaluate . must injected back evaluation context !! (single expression) !!! (list expressions). simple case, code equivalent usage {{ ... . Defusing enquo() enquos() needed complex cases, instance need inspect modify expressions way. .data pronoun object represents current slice data. variable name string, use .data pronoun subset variable [[. Another tidy eval operator :=. makes possible use glue curly-curly syntax LHS =. technical reasons, R language support complex expressions left =, use := workaround. Many tidy eval functions like dplyr::mutate() dplyr::summarise() give automatic name unnamed inputs. need create sort automatic names , use as_label(). instance, glue-tunnelling syntax can reproduced manually : Expressions defused enquo() (tunnelled {{) need simple column names, can arbitrarily complex. as_label() handles cases gracefully. code assumes simple column name, use as_name() instead. safer throws error input name expected.","code":"my_function <- function(data, var, ...) {   data %>%     group_by(...) %>%     summarise(mean = mean({{ var }})) } my_function <- function(data, var, ...) {   # Defuse   var <- enquo(var)   dots <- enquos(...)    # Inject   data %>%     group_by(!!!dots) %>%     summarise(mean = mean(!!var)) } my_var <- \"disp\" mtcars %>% summarise(mean = mean(.data[[my_var]])) my_function <- function(data, var, suffix = \"foo\") {   # Use `{{` to tunnel function arguments and the usual glue   # operator `{` to interpolate plain strings.   data %>%     summarise(\"{{ var }}_mean_{suffix}\" := mean({{ var }})) } my_function <- function(data, var, suffix = \"foo\") {   var <- enquo(var)   prefix <- as_label(var)   data %>%     summarise(\"{prefix}_mean_{suffix}\" := mean(!!var)) }"},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct rounding bounds — unround","title":"Reconstruct rounding bounds — unround","text":"unround() takes rounded number returns range original value: lower upper bounds hypothetical earlier number later rounded input number. also displays range inequation signs, showing whether bounds inclusive . default, presumed rounding method rounding () 5. See Rounding section methods.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct rounding bounds — unround","text":"","code":"unround(x, rounding = \"up_or_down\", threshold = 5, digits = NULL)"},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct rounding bounds — unround","text":"x String numeric. Rounded number. x needs string unless digits specified (likely function uses unround() helper). rounding String. Rounding method presumably used create x. Default \"up_or_down\". , see section Rounding. threshold Integer. Number round . rounding methods affected. Default 5. digits Integer. argument meant make unround() efficient use helper function need redundantly count decimal places. specify otherwise. Default NULL, case decimal places really counted internally x needs string.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct rounding bounds — unround","text":"tibble seven columns: range, rounding, lower, incl_lower, x, incl_upper, upper. range column handy representation information stored columns lower upper, order.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reconstruct rounding bounds — unround","text":"function vectorized x rounding. can useful unround multiple numbers , check single number unrounded different assumed rounding methods. vectors length greater 1, needs length. However, pair numbers rounding methods, can confusing. recommended least one input vectors length 1. x need string digits specified? case, unround() needs count decimal places . x numeric, trailing zeros get dropped numerics. Trailing zeros important reconstructing boundary values trailing digits . Strings drop trailing zeros, used instead.","code":""},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":"rounding","dir":"Reference","previous_headings":"","what":"Rounding","title":"Reconstruct rounding bounds — unround","text":"Depending x rounded, boundary values can inclusive exclusive. incl_lower incl_upper columns resulting tibble TRUE first case FALSE second. range column reflects equation inequation signs. However, ranges based assumptions way x rounded. Set rounding rounding method hypothetically lead x: Base R's round() (R version >= 4.0.0), referenced rounding = \"even\", reconstructed way \"up_or_down\", whether boundary values inclusive hard predict. Therefore, unround() checks , informs .","code":""},{"path":[]},{"path":"https://lhdjung.github.io/scrutiny/reference/unround.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reconstruct rounding bounds — unround","text":"","code":"# By default, the function assumes that `x` # was either rounded up or down: unround(x = \"2.7\") #> # A tibble: 1 × 7 #>   range                  rounding   lower incl_lower x     incl_upper upper #>   <chr>                  <chr>      <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 <= x(2.7) <= 2.75 up_or_down  2.65 TRUE       2.7   TRUE        2.75  # If `x` was rounded up, run this: unround(x = \"2.7\", rounding = \"up\") #> # A tibble: 1 × 7 #>   range                 rounding lower incl_lower x     incl_upper upper #>   <chr>                 <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 <= x(2.7) < 2.75 up        2.65 TRUE       2.7   FALSE       2.75  # Likewise with rounding down... unround(x = \"2.7\", rounding = \"down\") #> # A tibble: 1 × 7 #>   range                 rounding lower incl_lower x     incl_upper upper #>   <chr>                 <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 < x(2.7) <= 2.75 down      2.65 FALSE      2.7   TRUE        2.75  # ...and with `base::round()` which, broadly # speaking, rounds to the nearest even number: unround(x = \"2.7\", rounding = \"even\") #> # A tibble: 1 × 7 #>   range                rounding lower incl_lower x     incl_upper upper #>   <chr>                <chr>    <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 2.65 < x(2.7) < 2.75 even      2.65 FALSE      2.7   FALSE       2.75  # Multiple input number-strings return # multiple rows in the output data frame: unround(x = c(3.6, \"5.20\", 5.174)) #> # A tibble: 3 × 7 #>   range                        rounding  lower incl_lower x     incl_upper upper #>   <chr>                        <chr>     <dbl> <lgl>      <chr> <lgl>      <dbl> #> 1 3.55 <= x(3.6) <= 3.65       up_or_do…  3.55 TRUE       3.6   TRUE        3.65 #> 2 5.195 <= x(5.20) <= 5.205    up_or_do…  5.20 TRUE       5.20  TRUE        5.20 #> 3 5.1735 <= x(5.174) <= 5.1745 up_or_do…  5.17 TRUE       5.174 TRUE        5.17"},{"path":"https://lhdjung.github.io/scrutiny/news/index.html","id":"scrutiny-011","dir":"Changelog","previous_headings":"","what":"scrutiny 0.1.1","title":"scrutiny 0.1.1","text":"patch, mainly fixing bug used affect presentation input data grim_map()’s results. needs emphasized bug affected convenience feature, namely presentation certain input data output, GRIM test . Previously, percent set TRUE, x values converted percentages. need presented strings, percentage conversion involves restoring correct number trailing zeros. bug, , x values appearing output (internal computations!) restored “length” single longest one. now remedied, x values restored individually appropriate number trailing zeros. Another bugfix concerns versioning. Previously, package incorrect version number. now corrected. Another change remove outdated potentially misleading paragraph documentation reround_to_fraction().","code":""},{"path":"https://lhdjung.github.io/scrutiny/news/index.html","id":"scrutiny-010","dir":"Changelog","previous_headings":"","what":"scrutiny 0.1.0","title":"scrutiny 0.1.0","text":"version includes overhaul grim_plot(): extends function cover cases decimals values greater 2, using gradient instead raster. enables data-free calls grim_plot() new show_data argument. Resulting plots display background raster. mirrors Figure 1 Brown Heathers’ GRIM paper. (Although grim_plot() whole modeled figure, default addition empirical summary data specific scrutiny.) Like Brown Heathers, users may wish create raster-plots order demonstrate principled points. key parameters decimals rounding can controlled directly make lack information data. function now checks input means proportions (x) number decimal places. don’t, throws error. strict criterion can circumvented specifying decimals argument. However, since raster specific one number decimal places (hence interpreted regarding x values different number), recommended solution plot x values separately — number decimal places. show_full_range argument removed now think superfluous. Previously, space raster y-axis. now removed. Test result data points, shown blue /red default, now built top raster, makes distinct appearance. Two new functions, reround_to_fraction(), reround_to_fraction_level(), enable fractional rounding, inspired janitor::round_to_fraction(). example, might round 0.4 0.5 fractions 2. tells new functions apart come flexibility reround(). Furthermore, reround_to_fraction_level() closer conventional rounding function two. new version also fixes bug row_to_colnames(), rewriting function’s core. Another bug fixed grim() grim_map(), concerning show_rec: rounding strings lead four reconstructed numbers per x value rather just two, used case two values corresponding first two rounding procedures displayed output tibble. Now, four displayed, bearing appropriate names. Another bugfix threshold argument reround(), didn’t work properly . used affect higher-level functions grim(), grim_map(), debit(), debit_map(), well. default threshold now 5 functions. Note rounding 5 fully functional independently . Also reround(), rec argument renamed x accordance general naming conventions. decimals argument renamed digits accordance naming conventions among rounding functions. split_by_parens(), ellipsis support added protect user silent, unexpected results following named arguments tidy evaluation. ellipsis package added Suggests field DESCRIPTION. high-level functions, internal checks now determine lengths multiple arguments factored internal function call mutually congruent. , two arguments length > 1, need length (throw warning). Otherwise, explicit specific error message. Finally, minor refactoring small changes users generally won’t notice.","code":""},{"path":"https://lhdjung.github.io/scrutiny/news/index.html","id":"scrutiny-001","dir":"Changelog","previous_headings":"","what":"scrutiny 0.0.1","title":"scrutiny 0.0.1","text":"Added vignette packages error detection, called Related software. Exported grim_plot(). Minor refactoring.","code":""},{"path":"https://lhdjung.github.io/scrutiny/news/index.html","id":"scrutiny-0009000","dir":"Changelog","previous_headings":"","what":"scrutiny 0.0.0.9000","title":"scrutiny 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
